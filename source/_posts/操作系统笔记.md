---
title: 操作系统笔记
date: 2017-03-13 16:48:19
tags:
---
= =
<!--more-->

# 基础知识
1. 冯诺依曼存储程序思想
2. 计算机由五大部分组成：**输入设备**，**输出设备**，**存储器**，**运算器**，**控制器**。



# 多进程

为什么要多进程?

对比如下两段代码:
```
int sum = 0;
for(int i=0; i<1000000;i++){
    sum += i;
}

---

int sum = 0;
for(int i=0; i<1000000;i++){
    sum += i;
    System.out.println(sum);
}
```

对比下两者时间,可以不负责人的告诉你,涉及到IO操作的,其时间必然会很高.原因在于IO操作需要操作外设,所有的外设的速度都比CPU慢很多.那么在操作IO的时候,我们能不能跳过呢?

当然能,这就引入了多进程或多线程.

在操作输出,即System.out.println()时,CPU在等待输出,在等待的过程,可以切到其他的进程中,这样就有效的解决了时间消耗问题.

**进程**: 说白了,就是运行中的程序.

接着考虑这么一个问题,在执行某段代码后进行并发,执行另外一段程序,执行完毕后返回到最开始的程序,那么只需要改变寄存器的值就完了么?

当然不是,在切换的时候,需要保存现场,即记录原本的样子,这就引入了**PCB(Process Control Block)**

操作系统管理进程的核心就是PCB.

进程的管理中,存在运行队列,就绪队列,阻塞队列等,当前的运行队列中只有一个PCB,标志当前运行进程.
就绪态->运行态->阻塞态->就绪态  而运行态可以转换到任何一种状态


在就绪态转换运行态时候需要选择一个进程,选择哪个进程呢?这就需要**调度**.

多线程为什么比进程快呢?

原因在于多线程切换的时候只需要切换PC地址(可能还有其他内容),但是不会切换内存资源,或者是内存映射表,也不用切换其他寄存器地址,所以线程切换代价不大,并且切换速度快.

多线程分为用户级线程和内核级线程,用户级线程也有缺点,如果多线程中任何一个线程都触发了任务等待,比如IO操作,那么内核中就会进行进程切换,那么之前的进程中的所有线程都不会再执行.
而内核级线程就跟进程很相似,在切换的时候,可以对内核级线程进行切换.


# CPU调度：
调度算法：先来先服务(First come first Served)，短作业优先(可缩短平均周转时间，且平均周转时间最短，但是响应时间比较长)，时间片轮转调度(RR,时间片分为固定时间如T，则T时间后就交换另一个进程执行)

优先级调度(给进程一个优先级，优先级高的先调度，可能会出现饥饿现象)，
