---
title: 操作系统笔记
date: 2017-03-13 16:48:19
tags:
---
= =
<!--more-->

# 基础知识
1. 冯诺依曼存储程序思想
2. 计算机由五大部分组成：**输入设备**，**输出设备**，**存储器**，**运算器**，**控制器**。



# 多进程

为什么要多进程?

对比如下两段代码:
```
int sum = 0;
for(int i=0; i<1000000;i++){
    sum += i;
}

---

int sum = 0;
for(int i=0; i<1000000;i++){
    sum += i;
    System.out.println(sum);
}
```

对比下两者时间,可以不负责人的告诉你,涉及到IO操作的,其时间必然会很高.原因在于IO操作需要操作外设,所有的外设的速度都比CPU慢很多.那么在操作IO的时候,我们能不能跳过呢?

当然能,这就引入了多进程或多线程.

在操作输出,即System.out.println()时,CPU在等待输出,在等待的过程,可以切到其他的进程中,这样就有效的解决了时间消耗问题.

**进程**: 说白了,就是运行中的程序.

接着考虑这么一个问题,在执行某段代码后进行并发,执行另外一段程序,执行完毕后返回到最开始的程序,那么只需要改变寄存器的值就完了么?

当然不是,在切换的时候,需要保存现场,即记录原本的样子,这就引入了**PCB(Process Control Block)**

操作系统管理进程的核心就是PCB.

进程的管理中,存在运行队列,就绪队列,阻塞队列等,当前的运行队列中只有一个PCB,标志当前运行进程.
就绪态->运行态->阻塞态->就绪态  而运行态可以转换到任何一种状态


在就绪态转换运行态时候需要选择一个进程,选择哪个进程呢?这就需要**调度**.

多线程为什么比进程快呢?

原因在于多线程切换的时候只需要切换PC地址(可能还有其他内容),但是不会切换内存资源,或者是内存映射表,也不用切换其他寄存器地址,所以线程切换代价不大,并且切换速度快.

多线程分为用户级线程和内核级线程,用户级线程也有缺点,如果多线程中任何一个线程都触发了任务等待,比如IO操作,那么内核中就会进行进程切换,那么之前的进程中的所有线程都不会再执行.
而内核级线程就跟进程很相似,在切换的时候,可以对内核级线程进行切换.


# CPU调度：
调度算法：先来先服务(First come first Served)，短作业优先(可缩短平均周转时间，且平均周转时间最短，但是响应时间比较长)，时间片轮转调度(RR,时间片分为固定时间如T，则T时间后就交换另一个进程执行)

优先级调度(给进程一个优先级，优先级高的先调度，可能会出现饥饿现象)


# 信号量

单独的信号只能记录线程的true or false,也就是只能有两种信号，那么如果想要通过一个信号记录很多的信息，比如睡眠线程的个数等，所以就引入了信号量。

比如用信号量中的sem变量来记录当前sleep线程的个数，其值为负值，绝对值为sleep线程个数，所以sem = -2时，表明当前有两个睡眠的线程。

如下例子,sem初始化是0，如果sem初始为正值n，表明缓冲区中有n个资源，如果为负值-m,表明有m个进程在等待。P表示生产者，C表示消费者：
1. P1 sleep, sem = -1;
2. P2 sleep, sem = -2;
3. C wakeup() ,sem = -1;//唤醒阻塞队列的头部
4. C wakeup() , sem = 0;

如果执行完毕后，sem为0，但是sem为正数的情况下表明资源的数量，所以再次执行C程序的时候(注意，不会再调用wakeup方法，因为sem已经不是负值，表明当前没有睡眠进程)，sem++,接着P来消费的时候，sem--.

那么对于一种信号量的实现，通过一种结构体：
```
struct semaphore{
	int value; //记录资源个数，或等待进程个数
	PCB *queue; //等待进程队列
}

P(semaphore s){
	//消费资源
	s.value--;
	//我消费资源的前提是资源的个数>=1,而如果资源个数为0或者小于0，那么我就需要等待，其实这个地方写的不够好理解，可以将其修改为下面的P操作，容易理解
	if(s.value<0){
		//s.value<0时，表明当前没有我所需要的资源，则把当前进程放入等待队列
		sleep(s.queue);	
	}
}

等价于：
P(semaphore s){
   	//我消费前先判断是否有资源，如果没有，就等待
	if(s.value <= 0){
		s.value--;
		sleep(s.queue);
		return;
	}
	//如果有资源，那么就将资源减1
	s.value--;
}

V(semaphore s){
	//生产资源
	s.value++;
	//我生产资源的目的就是为了让消费进程使用，那么如果消费进程在等待，我就唤醒他们，所以调用以下方法，即判断是否有等待进程，如果有就唤醒
	if(s.value <= 0){
		//s.value <= 0 表明等待队列中有睡眠的进程，则唤醒进程，为什么==0的时候也唤醒？因为s.value之前的值为-1，即队列中有一个进程，需要唤醒。注意唤醒后，一定可以拿到资源，因为V操作生产了一个资源
		//如果s.value>0表明资源足够，并且等待队列中并没有需要唤醒的进程，所以根本就不用调用wakeup()，这里一定要搞清楚。
		wakeup(s.queue);
	}
}
```

为什么P是消费资源呢，其名称来源于荷兰语的proberen,即test,而V为verhogen(increment)


那么对于生产者消费者模式，如果使用信号量实现，可以通过以下代码，在看代码前，考虑这么一个问题，生产者可以进行sleep,消费者也可以sleep，就是说，两者是互斥的，那么应该使用几个信号量操作呢？
答案是两个，一个是生产者唤醒消费者的信号量，一个是消费者唤醒生产者的信号量。
所以定义两个信号量 一个是full的标识，一个是empty标识
```
semphore full = 0; //使用资源个数，full + empty  = Buffer_SIZE
semphore empty = BUFFER_SIZE;//空资源个数
semphore mutex = 1; //初始为1时，表明资源同时只能一个进程访问

Producer(item){
	P(emtpy); //empty-1,表明当前空闲位置的个数，如果空闲位置为0，则当前生产者等待
	P(mutex); //mutex为0时，说明Consumer在执行操作，则当前进程等待，从这里可以看出，信号量初始为1时，可以创建一个互斥访问的资源
	produce(); //生产
	V(mutex); //mutex++
	V(full); //full++ 生产结束，要把full标识资源个数+1，表明当前生产的资源个数
}

Consumer(){
	P(full); //full--,表明消费资源，如果full为0，则没资源，当前进程等待
	P(mutex);//同上
	consume();//消费
	V(mutex);//同上
	V(empty);//消费完毕，empty+1,即表明空闲位置个数 + 1
}
```

对于以上信号量，需要认真的查看，其实PV操作就是对0的操作，慢慢体会，说实话这些东西如果要自己去设计，真的设计不出来，天才的脑洞是真的大啊。


# 死锁
死锁的4个必要条件，以十字路口举例
1. 首先一个条件就是**互斥**，我访问的时候你不能访问，也就是说一条道路，只能有一列车辆进行行驶
2. 接着就是**不可剥夺**，我访问的时候，你没法把我挤出去，对于十字路口就是，只有我开走的时候，你才能过来
3. 然后就是**保持请求**，我在自己的资源中，还能申请别的资源，就如十字路口，我占用了我的道路，想要右拐，那么就是申请右拐的道路。
4. 最后就是**循环等待**，环路等待，即我等你，你等他，他等我。

记忆的话就是 互斥，剥夺，请求，等待。

互斥，剥夺是一条道路固有的属性，也就是进程自带的属性，一条道路不允许两列车同时行驶，并且其他车辆不能在有车的情况下剥夺其他车的使用权。

请求，就是我拐弯的时候需要申请其他道路的资源，而等待，就是等待其他道路的车辆开走。

这样记忆就没有问题了～

## 死锁预防
一次性申请所有资源
对资源类型进行排序，资源申请按虚进行，不会造成环路等待

## 死锁避免
判断请求是否会引起死锁，使用**银行家算法**

如果系统中所有进程存在一个可完成的执行序列P1,...Pn，则称为系统处于安全状态

也就是说银行家算法，就是寻找一个可以完美执行的序列P1,...Pn

例：


|进程|Allocation|Need|Avaiable|
|--|--|--|--|
| |A B C|A B C|A B C|
|P0|0 1 0|7 4 3|2 3 0|
|P1|3 0 2|0 2 0| |
|P2|3 0 2|6 0 0| |
|P3|2 1 1|0 1 0| |
|P4|0 0 2|4 3 1| |

求一个可执行序列。

其字母的含义是
Allocation:该进程被分配的资源个数(是该进程自带的，不是系统分配的)，比如P0执行的时候，A会分配0个资源，B会分配1个资源，C会分配0个资源。
Need:该进程执行时需要的资源数
Avaiable:当前系统中可以被分配的资源个数

其计算过程是：首先查看资源分配给谁时是可执行的，比如分配给P0,因其需要的资源个数是7 4 3，而可分配的是2 3 0 ，即P0不可执行，那么分配给P1时，是可执行的，那么P1执行完毕后，释放其自带的资源，那么可分配的资源数从2 3 0变为(2,3,0) + (3,0,2) = (5,3,2)，那么以此计算下去，找到一个可执行序列即可。


如果没有可执行序列，那么就会造成死锁，就不会进行资源分配。

银行家算法虽然很好，但是执行的代价比较大，其计算序列需要O(m * n^2)，n是进程的个数，m是每个进程中需要分配资源的个数，如上述ABC，m = 3.
n^2的计算方法是其序列首先要分配给P1，然后计算P1之后的安全序列，接着再首先分配给P2，再计算P2开头的安全序列，所以时间复杂度是n^2,那么综合一下，总的时间复杂度就是O(m * n^2)

##死锁检测＋恢复
发现问题再处理
当资源利用率低时进行检测，检测的方法和银行家算法一样，如果发现死锁就进行回滚，回滚的选择也需要进行选择，是选择优先级高的？占用资源多的？回滚的机制有很多，这里不再赘述(其实就是不知道嘛！)


## 死锁忽略
如果出现死锁就忽略，可以重启等。效率高，并且出现的概率比较低，如果使用其他死锁的预防检测恢复等方法，代价会比较高，并造成编程等困难。所以Windows,Linux等大多都采用了死锁忽略的方法。



