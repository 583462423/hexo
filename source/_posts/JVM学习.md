---
title: JVM学习
date: 2017-04-03 21:25:29
tags:
---

# 内存

java运行时数据区：
![](/images/java运行时数据区.png)

## 程序计数器
线程私有
当前所执行字节码的行号指示器。
唯一一个在JAVA虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

## 虚拟机栈
线程私有
每个方法在执行的同事都会创建一个栈帧(Stack Frame)存储局部变量表，操作数栈，动态链接，方法入口等信息。
局部变量表存放编译期可知的基本数据类型，对象引用。
该区域会抛出StackOverflowError异常。如果无法申请到足够的内存抛OutOfMemoryError.

## 本地方法栈
线程私有
为虚拟机使用到的native方法服务.
有的虚拟机(如 Sun HotSpot)直接把本地方法栈和虚拟机栈合二为一.

## JAVA堆
所有线程共享.
虚拟机启动时创建.
用于存放对象实例.
是垃圾收集器管理的主要区域,所以也称为GC堆.
分为新生代和老年代,再细致一点则分为Eden(伊甸园),From Survivor,To Survivor,老年代等.
Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可.


## 方法区
所有线程共享.
存储虚拟机加载的类信息(如类名,访问修饰符,常量池,字段描述),常量,静态变量,即时编译器(JIT)编译后的代码等数据.
别名:non-heap,永久代
垃圾收集行为在这个区域比较少出现,该区域内存回收目标主要针对常量池的回收和对类型的加载.

### 运行时常量池
是方法区的一部分.
Class文件中还有一项信息是常量池,用于存放编译器生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.
String.intern():如果字符串常量池中已经包含一个等于此String对象的字符串,则返回代表池中这个字符串的String对象;否则,将此String对象包含的字符串添加到常量池中,并且返回此String对象的引用,在测试运行时常量池内存溢出的时候,就可以使用该方法.

# 对象

## 对象的创建
遇到new指令时首先检查这个指令的参数能否在常量池中定位到一个类的符号引用,并且检查该符号代表的类是否已经被加载,解析和初始化,若没有则加载.

类加载检查通过后,为对象分配内存,对象所需内存大小在类加载完成后可完全确定.
Java堆规整时,采用指针碰撞分配内存,否则采用空闲列表.
虚拟机还要对对象进行必要的设置,在对象头(Object header)中设置对象哈希码,gc分代等等


## 对象的内存布局
HotSpot中,对象在内存中存储布局分为3块:对象头,实例数据和对齐填充.
对象头包含两部分,第一个部分存储的是对象自身运行时数据,如hashCode,GC分代,锁等.第二部分是类型指针,通过该指针确定这个对象是哪个类的实例.
如果对象是一个Java数组,在对象头必须有一块用于记录数组长度的数据

实例数据就是保存各种类型的字段内容,无论是父类继下来的还是子类定义的,都需要记录下来.

对齐填充不是必然存在的,仅仅起填充作用,因HotSpot自动内存管理系统要求对象起始地址必须是8字节的整数.如果数据没有对齐,那么就通过对齐填充来将对象数据对齐.

## 对象访问定位
通过栈中的引用来操作堆上的具体对象,但是Java虚拟机规范中没有定义这个引用应该如何定位,所以对不同虚拟机而言,定位方式也不同.主流的定位方式有句柄和直接指针两种.

句柄:Java堆中4划分出一块内存作为句柄池来存储句柄,栈中的对象引用就是存储的句柄地址,句柄包含对象实例数据和类型数据的地址.如:
![](/images/Java句柄.png)

直接指针:栈中引用存储的就是对象的地址,如:
![](/images/直接指针.png)

使用句柄的好处是存储稳定的句柄,对象被移动,只改变句柄的实例数据指针,引用本身不需要更改,直接指针的好处是速度更快.HotSpot使用的就是直接指针.


# 垃圾收集器和内存分配策略

## 对象是否存活

确定哪些对象还活着,使用的算法有引用计数法和可达性分析法,注意这两个方法不是垃圾收集算法,只是判断对象是否存活的方法.

### 引用计数法
给对象添加一个引用计数器,每当有一个地方引用它时,计数器加1,引用失效时,计数器减1.任何时刻计数器为0的对象就不可能再被使用.
主流的Java虚拟机里面没有使用该算法,原因在于它很难解决对象之间相互循环引用的问题.

### 可达性分析法
基本思想就是通过一系列的称为"GC Roots"的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连,即该对象从GC Roots不可达,证明此对象是不可用的.如图,Object5,6,7虽然互相关联,但是从GC Roots是不可达的,所以它们将被判定为是可回收对象.
![](/images/可达性分析.png)

Java中可以作为GC Roots的对象包括下面几种:
* 虚拟机栈(栈帧中的本地变量表)中引用的对象
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象

## 引用
JDK1.2后Java对引用的概念进行了扩充,将引用分为强引用(StrongReference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种,这4种引用强度依次逐渐减弱。

强引用就是指在程序代码之中普遍存在的,类似“Object obj=new Object()”这类的引用,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象。

软引用是内存不足的时候才会进行回收.

弱引用无论当前内存是否足够,都会回收掉只被弱引用关联的对象。

虚引用也称为幽灵引用或者幻影引用,它是最弱的一种引用关系。一个对象是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## 生存还是死亡
对于一个对象,如果可达性分析后发现不可达后,并非是非死不可的,这个时候它们只是处于缓刑阶段.

真正宣告一个对象死亡,至少经历两次标记过程:可达性分析后发现不可达的对象,将被第一次标记并进行筛选,筛选的条件是该对象是否有finalize()方法,如果没有覆盖或已覆盖但已执行过一次,则这些对象不会去执行finalize()方法.
如果对象有finalize()方法且从未被执行过,那么就会将该对象放在F-Queue队列中,并由虚拟机创建的低优先级的Finalizer线程去执行它.但不会等待该方法执行结束,原因在于怕导致阻塞现象.

fianlize()方法是对象自救的最后一次机会,如果自救成功,则finalize()方法就失效了,因为该方法只能被调用一次.一般不建议使用该方法,完全可以将之遗忘.


## 回收方法区

方法区的内存也是需要回收的.
永久代垃圾收集主要回收两部分内容:废弃常量和无用的类.
废弃常量举例来说,"abc"常量如果在程序中没有任何一个String的引用来指向它,如果有必要的话,"abc"就会被清理出常量池.

判断一个常量是否是废弃常量比较简单,但是判断是否是无用类比较苛刻:
* 该类的所有实例都已经被回收
* 加载该类的ClassLoader已被回收
* 该类对应的java.lang.Class对象没有在任何地方被引用,无法通过反射访问该类的方法.

## 垃圾收集算法

### 标记-清除算法
最基础的算法
分两个阶段:标记和清除,首先标记所有需要回收的对象,标记完成后进行清除工作.

缺点:效率不高;清除后产生空间碎片.
![](/images/标记清除算法.png)

### 复制算法
将内存分为大小相等的两块,每次只能使用一块,当一块内存用完时,将存活的对象复制到另一块上,并将之前的内存块清除.

缺点:浪费过多的资源,代价太高
![](/images/复制算法.png)


不过现在的商业虚拟机都采用这种算法来回收新生代,将内存分为较大的Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor,当回收时,将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上,最
后清理掉Eden和刚才用过的Survivor空间.

### 标记-整理算法
标记过程仍然与“标记-清除”算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉端边界以外的内存.如图:

![](/images/标记-整理.png)

### 分代收集算法
当前商业虚拟机的垃圾收集都采用该算法,将Java堆内存分为几块,一般分为老年代和新生代,新生代中采用复制算法,老年代中采用标记-整理或标记清除算法.

### HotSpot采用的算法

首先要**枚举根节点**,即GC roots,但是一般根节点有数百兆,这样会消耗更多内存.
进行GC的时候,不能出现分析过程中对象的引用关系还在不断变化的情况,所以在GC进行时必须停顿所有的Java线程.
准确式内存管理即虚拟机可以知道内存中某个位置的数据具体是什么类型.
目前主流的Java虚拟机使用的都是准确是GC,所以当执行系统停顿下来后,并不需要一个不漏地检查完所有执行上下文和全局的引用位置,虚拟机应当是有办法直接得知哪些地方存放着对象引用.HotSpot的实现中,使用OopMap数据结构来达到这个目的.类加载完成的时候,HotSpot会把对象内偏移量上是什么数据类型计算出来,在JIT编译过程中,也会在特定位置记录栈和寄存器中哪些位置是引用.这样GC扫描的时候就可以直接得知这些信息了.

**安全点**:如果为每一条指令都分配OopMap,将会需要大量额外空间.而HotSpot也不是为每条指令生成OopMap,只是在特定位置记录这些信息,将这些位置称为安全点,即程序执行时并非在所有地方都能停顿下来开始GC,只有在到达安全点时才能暂停.
GC发生时要让所有线程跑到安全点再停顿下来,采用的方式有两种:抢先式中断和主动式中断,其中抢先式中断不需
要线程的执行代码主动去配合,在GC发生时,首先把所有线程全部中断,如果发现有线程中断的地方不在安全点上,就恢复线程,让它“跑”到安全点上.	现在几乎没有虚拟机采用这种方式.而主动式中断的思想是当GC需要中断线程的时候,不直接对线程操作,仅仅简单地设置一个标志,各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己中断挂起。


**安全区域**:如果遇到线程sleep而长时间无法到达安全点,JVM显然不可能等到线程sleep结束才去中断其运行,这个时候就需要安全区域.安全区域是指:在一段代码片段之中,引用关系不会发生变化.所以安全区域中任意地方开始GC都是安全的.

## 垃圾收集器

Serial收集器:单线程收集器,新生代
ParNew收集器:Serial收集器的多线程版本
Parallel Scavenge:新生代收集器,使用复制算法,又是并行的多线程收集器
Serial Old:Serial的老年代版本,标记-整理算法
Parallel Old:老年代版本,使用多线程和标记-整理算法

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上,这类应用尤其重视服务的响应速度,希望系统停顿时间最短,以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。
使用标记清除算法实现,整个步骤分为4步:
1. 初始标记(CMS initial mark)
2. 并发标记(CMS concurrent mark)
3. 重新标记(CMS remark)
4. 并发清除(CMS concurrent sweep)
初始标记和重新标记需要暂停其他所有线程(Stop The World),初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快,并发标记阶段就是进行GC RootsTracing的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起
工作,所以,从总体上来说,CMS收集器的内存回收过程是与用户线程一起并发执行的。

G1收集器:反正就是一个很吊的收集器...

上网搜刮的两张图片:
![](/images/收集器.png)

![](/images/收集器关系.png)

## 内存分配与回收策略
大多数情况下,对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC。

Minor GC:指发生在新生代的垃圾收集动作,因为Java对象大多都具备朝生夕灭的特性,所以Minor GC非常频繁,一般回收速度也比较快。
Major GC/Full GC:指发生在老年代的GC,出现了Major GC,经常会伴随至少一次的Minor GC(但非绝对的,在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。

**大对象直接进入老年代**
所谓的大对象是指,需要大量连续内存空间的Java对象,最典型的大对象就是那种很长的字符串以及数组(笔者列出的例子中的byte[]数组就是典型的大对象)。大对象对虚拟机的内存分配来说就是一个坏消息(替Java虚拟机抱怨一句,比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”,写程序的时候应当避免),经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。


**长期存活的对象将进入老年代**
虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能被
Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁),就将会被晋升到老年代中。




