---
title: 计算机网络学习笔记
date: 2017-03-12 12:20:06
tags:
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

计算机网络因为在校没有认真学，所以现在需要重新学习一下，记录下学习笔记。

<!--more-->

# 什么是计算机网路

定义：计算机网络就是**互连**的、**自治**的的计算机集合。

**协议**:计算机网络中的数据交换必须遵守实现约定好的协议。网络协议，简称为协议，是为进行网络中数据交换而建立的规则、标准或约定。协议规定了通信实体之间所交换消息的格式、意义、顺序以及针对收到的消息或发送的事件所采取的动作。

**协议三要素**:语法、语义、时序



# 数据交换

数据交换分为：电路交换、报文交换、分组交换

## 电路交换

最典型的电路交换网络：电话网络。

电路交换的三个阶段：建立连接、通信、释放连接。

其特点是独占资源，就是说当我占用这个资源，即使不通信，不传送数据，那么其他人也不能使用。

### 多路复用

电路交换中使用多路复用的方式进行复用。

典型的多路复用有：*频分多路复用*、*时分多路复用*、*波分多路复用*、*码分多路复用*。

频分即频路，时分即时间，波分即波长（针对光的传播）。

#### 码分复用

码分复用比较复杂，其需要符合以下条件：
* 每个用户分配一个唯一的m bit码片序列，其中0用`-1`表示，1用`+1`表示，如00011011的码片序列为：`-1-1-1+1+1-1+1+1`.
* 各用户使用相同频率载波
* 编码信号 = (原始数据) x (码片序列)，比如发送1，则使用 +1 和码片序列进行积运算，结果还是码片序列。而发送0，则使用 -1 和码片序列进行积运算，结果是码片序列的反码表示
* 各用户码片序列相互正交(两两正交)

## 报文交换

报文交换即一次将信息整体发出。

## 分组交换

将信息整体拆分为一系列相对较小的数据包，其需要在每个分组前加上头数据包。

分组交换也可被称为统计多路复用。

报文交换和分组交换，均采用**存储-转发**的交换方式


## 报文交换和分组交换时延计算

### 报文交换
报文长度为**M**bits
链路带宽为**R**bps
每次传送报文需要M/R秒

### 分组交换
报文:**M**bits
链路带宽:**R**bps
分组长度：**L**bits
路由器数目：**n**

则:
$$
T = M/R + nL/R
$$


例题：

在某个分组交换网络中，所有链路的数据传输速率为100Mbps，分组大小为1000B，其中分组头大小为20B，如果H1主机向H2主机发送一个大小为980000B的文件，不考虑分组拆装事件和传播事延的情况下，则H1发送开始到H2接收完为止，需要多长时间。其中经过路由器个数为2

答案：
根据T = M/R + nL/R

因为每个组为1000B数据，则每组可以传送980B的数据，一共980000B文件，所以可以拆分为980000/980 = 1000组。而共传送的数据大小为 1000 * 1000 = 1000000B
所以最终结果为 T = （1 000 000B * 8）/（100Mbps*1000000） + (2*1000*8)/(100Mbps*1000000) = 80.16ms

# 计算机网络性能

**速率**：数据传输速率，即单位时间内传输信息量。
**带宽**：指传输最高数据传输速率。
**延迟/时延**

分组交换为什么会发生丢包和时延？
原因在于分组在路由器中进行排队，而缓存队列满了的时候，再传输过来的分组数据就会被丢掉，这就是丢包。而时延通常包含节点处理延迟，排队延迟，传输延迟以及传播延迟。

注意传输延迟和传播延迟的区别，传播延迟是传播过程的延迟。

**时延带宽积**： = 传播时延 * 带宽 。单位是bit。 说白了，就是某段链路有多少个bit长度。
**吞吐量**：类比InputStream,Reader等，吞吐量就是总体链路上的传播速率，假设A1链路传播速率是R1,A2传播速率是R2，如果R1<R2，那么结果是以R1为标准的。



# 计算机网络体系结构

## OSI参考模型
1984年由于**国际标准化组织(ISO)**提出的分层网络体系结构模型

划分7层：**物理层**、**数据链路层**、**网络层**、**传输层**、**会话层**、**表示层**、**应用层**。

那么对于计算机之间传输数据时，主机要完成**7**层所有协议，而对于路由器来讲，只需要完成**3**层协议，即**物理层**、**数据链路层**、**网络层**。

物理层：定义接口特性（机械、电气、功能、规程），比特编码，数据率，比特同步（时钟同步），传输模式（单工[如电视]，半双工[同一时间只能一方发送数据，如对讲机]，全双工[电话]）。 俗：发比特数据。
数据链路层：负责结点间的数据传输，封装成帧，**物理寻址**(在帧头增加物理地址表示数据发送端/接受端)，流量控制,差错控制，接入控制等。俗：封装成帧并寻址。
网络层：逻辑寻址(全局地址唯一：**IP**)，**路由**,分组转发。

注意逻辑寻址和物理寻址的差别，物理寻址是寻找下个介质的地址，逻辑寻址是寻找目的主机的地址，其中逻辑寻址的地址是不变的，而物理地址在每次传送到中间介质后都要改变。

传输层：负责端到端完整报文传输(**TCP**,**UDP**)，SAP寻址(确保数据交给正确的端口号)
会话层：负责会话控制如同步等功能。
表示层：数据如何表示，对应用层的数据进行加密解密等
应用层：HTTP,SMTP，FTP等。


## TCP/IP参考模型
四层参考模型：网际接口层、网络层、传输层、应用层

而结合TCP和OSI参考模型后，生成了5层参考模型：物理层、数据链路层、网络层、传输层、应用层。

对于五层模型，主机要实现5层模型，而交换器需要实现2层[物理层，数据链路层]，路由器需要实现3层[物理层、数据链路层、网络层]


# 应用层

## 网络应用体系结构

**客户机/服务器:C/S**
**点对点:P2P**:没有永久在线的服务器,任意节点间都可以直接通讯,提供服务又使用服务.如:BT.缺点是**难于管理**.优点是**高度可伸缩**
**混合结构:上述两种的混合**:比如文件传输用P2P,文件搜索用C/S.

## 网络应用进程间通信
同一主机上进程间通信机制由操作系统提供.

而不同主机间的进程通信:**消息交换**
进程间通信利用**socket**发送/接受消息实现.网络开发API就是Socket.

进程的寻址是通过IP+端口号的方式.

## 应用层协议
交互的软件是要遵循应用层协议.
公开的协议由RFC定义.保证了软件间可以相互操作.
如果要仔细的研究某个协议,就可以去读取RFC文档.
比如公开的协议有:HTTP,SMTP,FTP等.

还有私有协议,就是非公开的,比如很多P2P文件共享协议都是私有的.

应用层协议会规定:消息类型(请求消息or响应消息),消息的语法(字段,描述),消息的语义(字段信息含义),规则等.

## 网络应用对传输服务的要求
* 数据丢失/可靠性:某些网络应用能够容忍数据丢失,如网络电话,而某些要求100%数据传输,如文件传输
* 延迟:某些应用在延迟足够低时才有效
* 带宽:email可以适应任何带宽,但是实时的软件是带宽必须达到某一要求才能顺利工作.

Internet提供两类传输服务:**TCP**,**UDP**

TCP:C/S间需要建立链接,可靠的传输,流量控制,拥塞控制等.
UDP:不需要建立链接,不可靠的数据传输.

比如:网络电话使用的UDP

## WEB应用
遵循的协议:HTTP
采用C/S结构
使用TCP传输服务

HTTP协议是无状态协议,即服务器并不会例会你的请求状态,你之前访问过我也不会记录,访问1000次我也会返回某一同一类型的内容.

### HTTP
HTTP有两种连接方式:非持久性连接(HTTP1.0)和持久性连接(HTTP1.1).
非持久性连接:每个TCP连接最多允许传输一个对象.
持久性连接:每个TCP连接允许传输多个对象

那么两者有何区别?
比如要访问www.qxgzone.com,假设该域名内包含十张图片,那么非持久连接其执行步骤如下:
1. 客户端发送TCP请求建立连接.服务端在80端口等待TCP连接请求.
2. 客户端将Socket套接字发出.服务端收到后解析并将要请求的数据通过套接字返回给客户端
3. 服务端关闭TCP连接.
4. 客户端收到返回的数据开始解析.解析后发现还需要10张图片,那么就重复执行上述1,2,3,4步骤

其缺点可见:执行需要消耗很多时间,每个TCP需要开销

而持久性连接，其发送响应后服务器保持TCP连接，后续的HTTP消息可以通过该连接发送。

持久性连接又包含了无流水的持久性连接和带有流水机制的持久性连接。
无流水的持久性连接是客户端收到服务端的响应后才发送下一个请求，而流水机制的持久性连接是客户端一旦遇到一个需要请求的对象就会发送连接。
HTTP1.1默认选项是带有流水机制的持久性连接。

#### 格式
HTTP有两类消息，请求消息(request)和响应消息(response).
请求消息的通用格式包含：请求行(request line)，请求头行(header line,主要是header中的一系列key-value值)以及消息体(POST的数据放入该结构中)等。
请求行包含:method,url,version，比如:`POST http://www.someurl.com HTTP/1.1`
header line就包含一些列参数键值对，比如accept,content-type等
请求体(消息体)包含自定义的一些参数等。

HTTP1.0版本中请求消息有：GET,POST,HEAD(请服务器不要将所请求的对象放入响应消息中)等方式
HTTP1.1增加了两种方法：PUT(将消息体中的文件上传到URL字段所指定的路径)，DELETE（删除URL字段所指定的文件）

响应消息包含：状态行，header line,以及返回的数据


#### Cookie
HTTP是无状态的，但是很多服务器需要掌握用户的状态，所以就出现了Cookie。

某些网站为辨别用户身份，进行Session跟踪而存储在用户本地终端上的数据。

Cookie可用于身份认证，购物车，应用推荐...

而其也有缺点，用户的一举一动都是被监测的。

现各大巨头公司正在研究代替Cookie的技术。

#### Web缓存/代理服务器
在不访问服务器的前提下满足客户端的HTTP请求。

在客户端和服务器之间架设一台代理服务器，请求发送给代理服务器，代理服务器从缓存中取数据。

一台代理服务器可以代理多台服务器。

一般由ISP架设。

但是缓存如何实时和服务器的数据保持一致呢？

其使用的条件性GET，其中有个参数是If-modified-since:<data>，代理服务器向服务器发送该条数据，如果数据没改变，就仅仅只返回一个状态码(304 Not Modified)数据，其他都不返回，减少流量的浪费。


## Socket套接字

应用层和传输层之间传输数据的接口就是　应用编程接口，比较典型的就是Socket。

应用层的程序由应用进程控制，而应用层以下则由操作系统控制。

对于一个套接字来说，对外来明确地址时，通过IP地址+ 端口号。

了解请戳：http://network.51cto.com/art/201412/459619_all.htm
Java socket：http://www.cnblogs.com/rocomp/p/4790340.html

# 传输层

多路复用/分用,UDP/TCP,不可靠/可靠信息传输,流水线机制和滑动窗口协议.

RDT3.0是发送数据后等待接受确认码后才能发送下一个数据.这样的缺点是增加了传送时间.
解决方式是,连续发送多个分组后再等待确认码.

那么这个时候就提出问题了,发送多个分组后,发送方或接收方如果存储不了怎么办?这个时候就需要使用缓存.
这就是流水线机制,不停的发送分组数据,并不停接受ACK确认码.如果要实现流水线,需要缓存以及滑动窗口协议.

滑动窗口协议:在发送数据的时候,数据会有序列,比如1~n的序列,而窗口就是为了管理这些等待确认的序列,注意是等待被确认,也就是说这些数据被发送出去了,但是发送方还未接收到接收方发送回来的ACK确认码.那么窗口尺寸为N时,表示最多有N个等待确认的消息.

而滑动窗口是确认后,窗口向前滑动.

窗口尺寸是N时,窗口左边是已发送且已确认的,窗口中存在已发送未接受确认的数据序列,也存在未发送的数据序列,窗口的右边就是待发送的数据序列.那么到此就明确了,窗口为N时候,为什么标识最多有N个等待确认的消息,如果发送了N个,但是未接受到确认,那么该窗口只能等待.

滑动窗口协议要学习GBN,SR,这是两种滑动窗口协议.

对于GBK协议而言,分组头部的K位标识序列号,也就是2^k个序列，也就说对于任何一个传送的数据，其标识的序列是0~2^k-1,不可能超过该序列，比如序列标识是0~4，那么对于一段数据而言，其整体序列就是012340123401234，也就是说，序列到头的时候，会从0继续开始.ACK确认码确认收到的序列号n,表示n之前的序列包括n都已经正确接受了.
当n+1分组发生了超时时间,就会从n+1开始进行重传，无论前边是否已经发送过。
所以这种协议潜在的会造成资源浪费。

例：数据链路层采用后退N帧(GBN)协议，发送方已经发送了编号为0~7的帧，当计时器超时时，若发送方只接受到0,2,3帧的确认，则发送方需要重发的帧数是多少，分别是哪几个帧。
答：重发4～7，虽然1确认帧没收到，但是最终收到的是3确认帧，表示3之前包含3都已经被成功接受，所以重发时，只能重发4往后的帧。

SR(send/receive)协议相对于GBN协议而言，他并不会丢弃已经发送的数据，接收方可以接受乱序到达的序列。接收方会对每个分组进行单独的确认，设置缓存机制，来缓存乱序到达的分组，而发送发只需要重传没收到ACK的分组。
注意该协议是发送方和接收方都有窗口，接收方的窗口最左边发送ACK后，整个窗口就开始右移，而发送方窗口最左接受到ACK,整个窗口才会右移。

SR中可用序列号和窗口尺寸是有要求的，发送方窗口尺寸 + 接受方窗口尺寸 < 序列号总数

