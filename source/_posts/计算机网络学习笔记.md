---
title: 计算机网络学习笔记
date: 2017-03-12 12:20:06
tags:
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

计算机网络因为在校没有认真学，所以现在需要重新学习一下，记录下学习笔记。

<!--more-->

# 什么是计算机网路

定义：计算机网络就是**互连**的、**自治**的的计算机集合。

**协议**:计算机网络中的数据交换必须遵守实现约定好的协议。网络协议，简称为协议，是为进行网络中数据交换而建立的规则、标准或约定。协议规定了通信实体之间所交换消息的格式、意义、顺序以及针对收到的消息或发送的事件所采取的动作。

**协议三要素**:语法、语义、时序



# 数据交换

数据交换分为：电路交换、报文交换、分组交换

## 电路交换

最典型的电路交换网络：电话网络。

电路交换的三个阶段：建立连接、通信、释放连接。

其特点是独占资源，就是说当我占用这个资源，即使不通信，不传送数据，那么其他人也不能使用。

### 多路复用

电路交换中使用多路复用的方式进行复用。

典型的多路复用有：*频分多路复用*、*时分多路复用*、*波分多路复用*、*码分多路复用*。

频分即频路，时分即时间，波分即波长（针对光的传播）。

#### 码分复用

码分复用比较复杂，其需要符合以下条件：
* 每个用户分配一个唯一的m bit码片序列，其中0用`-1`表示，1用`+1`表示，如00011011的码片序列为：`-1-1-1+1+1-1+1+1`.
* 各用户使用相同频率载波
* 编码信号 = (原始数据) x (码片序列)，比如发送1，则使用 +1 和码片序列进行积运算，结果还是码片序列。而发送0，则使用 -1 和码片序列进行积运算，结果是码片序列的反码表示
* 各用户码片序列相互正交(两两正交)

## 报文交换

报文交换即一次将信息整体发出。

## 分组交换

将信息整体拆分为一系列相对较小的数据包，其需要在每个分组前加上头数据包。

分组交换也可被称为统计多路复用。

报文交换和分组交换，均采用**存储-转发**的交换方式


## 报文交换和分组交换时延计算

### 报文交换
报文长度为**M**bits
链路带宽为**R**bps
每次传送报文需要M/R秒

### 分组交换
报文:**M**bits
链路带宽:**R**bps
分组长度：**L**bits
路由器数目：**n**

则:
$$
T = M/R + nL/R
$$


例题：

在某个分组交换网络中，所有链路的数据传输速率为100Mbps，分组大小为1000B，其中分组头大小为20B，如果H1主机向H2主机发送一个大小为980000B的文件，不考虑分组拆装事件和传播事延的情况下，则H1发送开始到H2接收完为止，需要多长时间。其中经过路由器个数为2

答案：
根据T = M/R + nL/R

因为每个组为1000B数据，则每组可以传送980B的数据，一共980000B文件，所以可以拆分为980000/980 = 1000组。而共传送的数据大小为 1000 * 1000 = 1000000B
所以最终结果为 T = （1 000 000B * 8）/（100Mbps*1000000） + (2*1000*8)/(100Mbps*1000000) = 80.16ms

# 计算机网络性能

**速率**：数据传输速率，即单位时间内传输信息量。
**带宽**：指传输最高数据传输速率。
**延迟/时延**

分组交换为什么会发生丢包和时延？
原因在于分组在路由器中进行排队，而缓存队列满了的时候，再传输过来的分组数据就会被丢掉，这就是丢包。而时延通常包含节点处理延迟，排队延迟，传输延迟以及传播延迟。

注意传输延迟和传播延迟的区别，传播延迟是传播过程的延迟。

**时延带宽积**： = 传播时延 * 带宽 。单位是bit。 说白了，就是某段链路有多少个bit长度。
**吞吐量**：类比InputStream,Reader等，吞吐量就是总体链路上的传播速率，假设A1链路传播速率是R1,A2传播速率是R2，如果R1<R2，那么结果是以R1为标准的。



# 计算机网络体系结构

## OSI参考模型
1984年由于**国际标准化组织(ISO)**提出的分层网络体系结构模型

划分7层：**物理层**、**数据链路层**、**网络层**、**传输层**、**会话层**、**表示层**、**应用层**。

那么对于计算机之间传输数据时，主机要完成**7**层所有协议，而对于路由器来讲，只需要完成**3**层协议，即**物理层**、**数据链路层**、**网络层**。

物理层：定义接口特性（机械、电气、功能、规程），比特编码，数据率，比特同步（时钟同步），传输模式（单工[如电视]，半双工[同一时间只能一方发送数据，如对讲机]，全双工[电话]）。 俗：发比特数据。
数据链路层：负责结点间的数据传输，封装成帧，**物理寻址**(在帧头增加物理地址表示数据发送端/接受端)，流量控制,差错控制，接入控制等。俗：封装成帧并寻址。
网络层：逻辑寻址(全局地址唯一：**IP**)，**路由**,分组转发。

注意逻辑寻址和物理寻址的差别，物理寻址是寻找下个介质的地址，逻辑寻址是寻找目的主机的地址，其中逻辑寻址的地址是不变的，而物理地址在每次传送到中间介质后都要改变。

传输层：负责端到端完整报文传输(**TCP**,**UDP**)，SAP寻址(确保数据交给正确的端口号)
会话层：负责会话控制如同步等功能。
表示层：数据如何表示，对应用层的数据进行加密解密等
应用层：HTTP,SMTP，FTP等。


## TCP/IP参考模型
四层参考模型：网际接口层、网络层、传输层、应用层

而结合TCP和OSI参考模型后，生成了5层参考模型：物理层、数据链路层、网络层、传输层、应用层。

对于五层模型，主机要实现5层模型，而交换器需要实现2层[物理层，数据链路层]，路由器需要实现3层[物理层、数据链路层、网络层]


# 应用层

## 网络应用体系结构

**客户机/服务器:C/S**
**点对点:P2P**:没有永久在线的服务器,任意节点间都可以直接通讯,提供服务又使用服务.如:BT.缺点是**难于管理**.优点是**高度可伸缩**
**混合结构:上述两种的混合**:比如文件传输用P2P,文件搜索用C/S.

## 网络应用进程间通信
同一主机上进程间通信机制由操作系统提供.

而不同主机间的进程通信:**消息交换**
进程间通信利用**socket**发送/接受消息实现.网络开发API就是Socket.

进程的寻址是通过IP+端口号的方式.

## 应用层协议
交互的软件是要遵循应用层协议.
公开的协议由RFC定义.保证了软件间可以相互操作.
如果要仔细的研究某个协议,就可以去读取RFC文档.
比如公开的协议有:HTTP,SMTP,FTP等.

还有私有协议,就是非公开的,比如很多P2P文件共享协议都是私有的.

应用层协议会规定:消息类型(请求消息or响应消息),消息的语法(字段,描述),消息的语义(字段信息含义),规则等.

## 网络应用对传输服务的要求
* 数据丢失/可靠性:某些网络应用能够容忍数据丢失,如网络电话,而某些要求100%数据传输,如文件传输
* 延迟:某些应用在延迟足够低时才有效
* 带宽:email可以适应任何带宽,但是实时的软件是带宽必须达到某一要求才能顺利工作.

Internet提供两类传输服务:**TCP**,**UDP**

TCP:C/S间需要建立链接,可靠的传输,流量控制,拥塞控制等.
UDP:不需要建立链接,不可靠的数据传输.

比如:网络电话使用的UDP

## WEB应用
遵循的协议:HTTP
采用C/S结构
使用TCP传输服务

HTTP协议是无状态协议,即服务器并不会例会你的请求状态,你之前访问过我也不会记录,访问1000次我也会返回某一同一类型的内容.

### HTTP
HTTP有两种连接方式:非持久性连接(HTTP1.0)和持久性连接(HTTP1.1).
非持久性连接:每个TCP连接最多允许传输一个对象.
持久性连接:每个TCP连接允许传输多个对象

那么两者有何区别?
比如要访问www.qxgzone.com,假设该域名内包含十张图片,那么非持久连接其执行步骤如下:
1. 客户端发送TCP请求建立连接.服务端在80端口等待TCP连接请求.
2. 客户端将Socket套接字发出.服务端收到后解析并将要请求的数据通过套接字返回给客户端
3. 服务端关闭TCP连接.
4. 客户端收到返回的数据开始解析.解析后发现还需要10张图片,那么就重复执行上述1,2,3,4步骤

其缺点可见:执行需要消耗很多时间,每个TCP需要开销

而持久性连接，其发送响应后服务器保持TCP连接，后续的HTTP消息可以通过该连接发送。

持久性连接又包含了无流水的持久性连接和带有流水机制的持久性连接。
无流水的持久性连接是客户端收到服务端的响应后才发送下一个请求，而流水机制的持久性连接是客户端一旦遇到一个需要请求的对象就会发送连接。
HTTP1.1默认选项是带有流水机制的持久性连接。

#### 格式
HTTP有两类消息，请求消息(request)和响应消息(response).
请求消息的通用格式包含：请求行(request line)，请求头行(header line,主要是header中的一系列key-value值)以及消息体(POST的数据放入该结构中)等。

HTTP1.0版本中请求消息有：GET,POST,HEAD(请服务器不要将所请求的对象放入响应消息中)等方式
HTTP1.1增加了两种方法：PUT(将消息体中的文件上传到URL字段所指定的路径)，DELETE（删除URL字段所指定的文件）

响应消息包含：状态行，header line,以及返回的数据


#### Cookie
HTTP是无状态的，但是很多服务器需要掌握用户的状态，所以就出现了Cookie。

某些网站为辨别用户身份，进行Session跟踪而存储在用户本地终端上的数据。

Cookie可用于身份认证，购物车，应用推荐...

而其也有缺点，用户的一举一动都是被监测的。

现各大巨头公司正在研究代替Cookie的技术。

#### Web缓存/代理服务器
在不访问服务器的前提下满足客户端的HTTP请求。

在客户端和服务器之间架设一台代理服务器，请求发送给代理服务器，代理服务器从缓存中取数据。

一台代理服务器可以代理多台服务器。

一般由ISP架设。

但是缓存如何实时和服务器的数据保持一致呢？

其使用的条件性GET，其中有个参数是If-modified-since:<data>，代理服务器向服务器发送该条数据，如果数据没改变，就仅仅只返回一个状态码(304 Not Modified)数据，其他都不返回，减少流量的浪费。


