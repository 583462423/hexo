---
title: 安卓有关面试题
date: 2017-03-06 14:27:24
tags:
---

什么?你想点开看?对不起,这只是个标题,里面没有任何内容,请回吧!

我说的是真的,是真的.
<!--more-->

好吧,你还是点开了.


# JAVA基础

## 对抽象，多态，继承的理解

### 继承

首先继承是最好理解的，从字面意思来讲，继承家业中的继承跟JAVA中的继承基本是一个意思，子类继承父类，那么子类就会拥有父类所有公开的内容，即共有属性和方法，不过不会拥有私有内容。我所理解的，其实是子类继承了父类的私有属性，不过不可访问，所以看起来像是没有继承。

### 抽象

从小对抽象的认识都是很抽象的，一直不理解抽象到底是什么意思。到我接触JAVA语言还是很不理解。语文中的抽象指的是无法感触到并不是实际存在的东西，类似只可意会。JAVA中的抽象，有抽象类，抽象类中又有抽象属性和抽象方法。刚开始所理解的抽象是通过一个例子，比如苹果，梨，西瓜他们都是水果，那么水果又是什么呢，水果就是一个抽象的事务，当别人告诉你水果这个名词时，你并不能指出这是具体哪一种事物，这就是一种抽象。那么JAVA中的抽象有什么意义呢。我认为抽象的存在是为了继承，为了提供一系列的接口，比如我可以把水果定义为抽象，以后定义苹果类的时候，一定要继承水果抽象类，同样定义梨的时候，也需要继承水果抽象类，这样苹果和梨就有了共性，而如果我要操作苹果和梨，并且恰好操作的对象是苹果和梨共有的属性，那如果我对苹果和梨一个个的操作，可以编写相同的代码，但是如果有一群水果，我是不是要编写一群代码呢，怎么才能使得代码复用，这个时候就出现了多态。

### 多态

多态，多种形态，指对不同的事务做出不同的反应。
网上给的解释很nice,直接摘抄下来:

多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）
实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。
多态的作用：消除类型之间的耦合关系。
现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。
再简单一点：坐公车时，一个男的靠在你的肩膀，你可能不爽，但是如果一个美女靠在你的肩膀你就很乐意，这就是多态的表现

多态有两种表现形式，重载和覆盖。
重载呢，就是该类有很多个同名的方法，但是传入不同的参数是，调用的方法就不一样，其中的操作也不一样。
覆盖呢，就是子类继承父类的时候，可以重写父类中的某一方法，重写的方法就会覆盖掉父类中的方法。

## 泛型的作用及使用场景

### 泛型的作用

泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。

Java语言引入泛型的好处是安全简单。

在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。

泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。

简言之，就是为了避免转换异常的发生，使得程序操作更安全简单。

### 使用场景

对于某一个类，如果其操作的对象是多种且不明确，但是每次操作的对象是唯一一种的，比如某个类可以操作学生对象，可以操作老师对象，可以操作职工对象，但是如果操作学生对象，那么这个类所有的方法都是操作学生。这个时候就可以使用泛型，想要操作哪个对象，就传入哪个类。

### 使用方法
1. 最简单的使用方法,定义class的时候传入泛型
```
public class Car<T> {
    private T car;

    public void setCar(T car) {
        this.car = car;
    }

    public T getCar() {
        return car;
    }
}

```

2. 定义class不传入泛型,但是class的方法需要使用泛型
```
public class Car {
    public <T> void someMethod(T car) {
        //some code
    }
}

```

如果直接写成下列样式就会报错
```
public class Car {
    public void someMethod(T car) {
        //some code
    }
}
```
鬼才知道你这个T是什么意思.

3. extends

```
//定义class的时候传入SuperCar的子类或本身
public class Car<T extends SuperCar> {
    public <T> void someMethod(T car) {
        //some code
    }
}

public class Car<T> {
    //指定传入的参数是SuperCar或其子类
    public <T extends SuperCar> void someMethod(T car) {
        //some code
    }
}

```
4. super 
与extends使用基本类似,不举...

5. 注意要点
泛型是编译阶段就会完成的任务,编译后的泛型class类中,是不会存在任何有关泛型的数据,比如指定new Car<String>(),这样编译后生成的class对象中是没有String类型的数据的,所以可以看如下代码:
```

    ArrayList<String> a = new ArrayList<String>(); //指定泛型是String类型
    a.add("some string"); 
    Class c = a.getClass(); 
    try{ 
        Method method = c.getMethod("add",Object.class);  
        method.invoke(a,100);  //虽然是String,但是在运行阶段,是没有泛型的数据,也就是说可以添加任何类型,注意反射是运行阶段才会调用的.
        System.out.println(a);  
    }catch(Exception e){ 
        e.printStackTrace();  
    } 

```

打印结果为:`[some string, 100]`
## 枚举的特点及使用场景

个人对枚举的理解不是很透彻，主要原因就是不经常使用，可以查看网上的用法总结：http://www.cnblogs.com/happyPawpaw/archive/2013/04/09/3009553.html

使用场景：控制某些值在某一范围内，比如枚举类型Color，其中有枚举量YELLOW,RED,GREEN等，但是不可能出现Cat,Dog等，这个时候就可以用枚举来定义Color这种类型。

## 线程sleep和wait的区别

我们来看看sleep的定义

```
public static native void sleep(long millis) throws InterruptedException;
public static void sleep (long millis,int nanos) throws InterruptedException;
```
millis是毫秒，nanos是纳秒。可以看到，两个都是静态方法，目的都是让某个线程沉睡，而传入的参数就是沉睡的时间，时间到了，线程自动苏醒。当调用了sleep之后，如果我想要这个线程在某个地方苏醒，就可以用Thread.interrupt()打断，这个时候，sleep也会结束，但是会抛出InterruptedException异常。

而wait方法是Object中的

```
public final void wait () throws InterruptedException{
	//some code
}
public final native void wait(long millis) throws InterruptedException;
public final void wait (long timeout,int nanos) throws InterruptedException{
	//some code
}
```
可见wait方法是final类型，不允许子类重写其方法。当调用某对象的wait()方法时，会释放该线程中的同步锁，并且等待调用该对象的notify(),或者其他对象的notifyAll()。

所以总结如下

1. 两个方法来自不同的类，sleep来自Thread,wait来自Object
2. sleep不会释放同步锁，wait会释放同步锁
3. sleep指定时间，时间不到，只能使用interrupt方法强制中断，wait可以不指定时间，等待调用对象的notify唤醒。
4. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，sleep可以在任何地方使用。如果wait，notify等方法不在同步块内使用，会抛出IllegalMonitorStateException异常，因为如果在不同线程中调用某个对象的wait,notify方法时，必须要求对该对象拥有控制权，而控制权在某一时间只能被一个线程拥有，所以要保证让线程拥有控制权就需要使用同步，比如下列代码就是保证对x有使用控制权。
```
synchronized(x)
{
	x.notify();
    //或x.wait();
}
```
## JAVA的反射机制

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

JAVA反射（放射）机制：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。但是JAVA有着一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。

### JAVA反射机制提供的功能

在运行时判断任意一个对象所属的类
在运行时构造任意一个类的对象
在运行时判断任意一个类所具有的成员变量和方法
在运行时调用任意一个对象的方法
生成动态代理
### 反射机制提供的类

java.lang.Class
java.lang.reflect.Constructor
java.lang.reflect.Field
java.lang.reflect.Method
java.lang.reflect.Modifier
### 功能实现

1.获取类的方法,假设有一个类叫Animal

```
//第一种方式
Class c = Class.forName("Animal"); //最常被使用
//第二种方式
Class c = Animal.class;
//第三种
Animal a = new Animal();
Class c = a.getClass();
//第四种
Class c = Boolean.TYPE;

```
2.获取类后，就可以创建对象。创建对象的方式：

```
Object o = c.newInstance(); //其中c是Class类型对象，此处调用的是c这个类中的无参构造方式
```
3.获取属性

```
Animal a = new Animal();
Class c = a.getClass();
//获取所有属性
Field[] fs = c.getDeclareFields();
//获取类的修饰符,即public void 等等
c.getModifiers();
//获取属性的修饰符
fs[0].getModifiers();
//获取属性的名字
fs[0].getName();
```

```
//获取指定属性，接着上个例子,假设Animal中有个属性是String name;
Animal cat = c.newInstance();
Filed nameField = c.getDeclareFields("name");//获取指定属性
nameField.setAccessible(true);
nameField.set(cat,"Cat"); //使用nameField给cat这个对象中的name属性赋值
```
4.获取方法

|方法关键字	|含义|
|---|------|----|
|getDeclaredMethods()|	获取所有的方法|
|getReturnType()|获得方法的返回类型|
|getParameterTypes()	|获得方法的传入参数类型|
|getDeclaredMethod(“方法名”,参数类型.class,……)|获得指定的方法|


|构造方法关键字|	含义|
|---|---|
|getDeclaredConstructors()|	获取所有的构造方法|
|getDeclaredConstructor(参数类型.class,……)|	获取特定的构造方法|

|父类和父接口	|含义|
|---|---|
|getSuperclass()	|获取某类的父类|
|getInterfaces()	|获取某类实现的接口|

有了这些方法，就可以获取类中的各种内容，就实现了反编译。

## weak/soft/strong引用的区别

JAVA中一共有4中类型引用：StrongReference、SoftReference、WeakReference、PhantomReference

java的引用跟GC有着密切联系。

强引用是JAVA默认的引用方式，比如A a = new A();只要引用存在，GC就不会回收对象的存储空间。

弱引用即WeakReference,引用的对象如果在JVM中没有强引用时，GC后，该类型的对象就会被回收。

```
Object o = new Object();
WeakReference`<Object> w = new WeakReference<Object>(o);
```
SoftReference 和WeakReference的特性一致，不过他会尽可能长的保留引用直到JVM内存不足才会回收。

```
Object o = new Object();
SoftReference`<Object> s = new SoftReference<Object>(o);
```

## Object的hashCode()与equals()的区别和作用


JAVA中的hashCode和equals是在HashSet和HashMap中有联系的，这两个集合的要求是，不能存储相同的对象或者相同的键，那么再存储一个对象的时候，如何才能判断当前集合中是否已经存在了该类对象呢？这就用到了equals方法和hashCode方法。

equals和hashCode方法都是Object中的方法。

默认情况下equals都是调用Object的equals方法，Object的equals方法是判断对象的内存地址是不是一样，即是不是指同一个对象。子类可以覆盖父类的equals方法，可以自定义其作用。比如比较两个类某一个值是否相等。

hashCode是返回一个int数，可以重写该方法，返回自定义int数。

当把对象放入Hash集合中的时候，首先判断是否有对象的hashCode和将要放入的对象的hashCode值相等，如果不相等，则直接放入，如果相等，则再通过equals方法判断如果不相等，则放入，如果相等，则不放入。

### 区别

hashCode 和 equals都可以用来判断两个对象是否相等。equals可以从内容上来判断，而hashCode是先给对象编码，然后通过编码的值来进行判断，并且，equals是在内部判断，返回结果，而hashCode是返回一个对象的hash值，判断方式需要自己写。比如，有一个Cat类，有两个对象白猫1，白猫2，使用equals判断就是重写equals，在内部写白猫之间判断是否相同的比较逻辑。而hashCode中定义猫编码的方式，后返回这个编码。

# JAVA集合

[集合面试题](http://jingyan.baidu.com/article/8065f87ff69c2623312498ce.html)

## java中常用集合类功能，区别和性能

首先看一个集合类图，这个我是在毕老师的学习教程下截的一个图，已经总结的很全面了。
![](/images/集合类图.png)

java中集合可以分为三类，如下

Set 集合
HashSet: 调用对象的hashCode()方法，获得哈希码，然后再集合中计算存放对象的位置。通过比较哈希码与equals()方法来判别是否重复。所以，重载了equals()方法同时也要重载hashCode()方法
TreeSet:继承ShortedSet接口，能够对集合中对象排序。默认排序方式是自然排序，但该方式只能对实现了Comparable接口的对象排序，java中对Integer、Byte、Double、Character、String等数值型和字符型对象都实现了该接口。
List集合
LinkedList: 链表结构
ArrayList：大小可变的数组,数组增长为原来的二分之一.
其增长源码是:`int newCapacity = oldCapacity + (oldCapacity >> 1);`
而Vector的增长源码是:`int newCapacity = oldCapacity + ((capacityIncrement > 0) ?capacityIncrement : oldCapacity);`

Map集合
HashMap：与hashSet相似，调用hashCode和equals方法来比较键是否相等，HashMap中不允许存在相同的键。
TreeMap：可自然排序，也可以通过传递Comparator的实现类构造TreeMap
集合的类型和使用方法比较多，所以有空可以去下列博文细读，总结的蛮详细的：http://www.360doc.com/content/12/0717/15/7662927_224736595.shtml

* HashTable和HashMap的区别
HashMap是线程不安全的,HashTable是线程安全的.
在存储方面,HashMap的源码是:
```
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }


    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```
可见,其存储的时候hash值是通过key来获取的,但是如果key为空,则hash值是0,所以对于HashMap来言,其键值是可以为null的,并且值也可以为null.
而HashTable的源码是:
```
	public synchronized V put(K key, V value) {
		// Make sure the value is not null
		if (value == null) {
		    throw new NullPointerException();
		}

		// Makes sure the key is not already in the hashtable.
		Entry<?,?> tab[] = table;
		int hash = key.hashCode();
		...
	}
```
可以看到,其存取的时候,首先会判断value是不是为空,如果为空抛出异常,而key值会调用key.hashCode()方法,当然key为空也会抛出异常,所以HashTable中key,value不能为空.

## 并发相关的集合类

[目前还没搞懂这个集合类有什么大的作用，想要学习戳这。](http://www.ibm.com/developerworks/cn/java/j-jtp07233/)

## 部分常用集合类的内部实现方式

这就是研究集合内部代码的过程嘛~

# 多线程

## Thread、Runnable、Callable、Futrue类关系与区别

Future是一个接口：
```
public interface Future<V> {

    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

而FutureTask是唯一实现Future的接口：
```
public class FutureTask<V> implements RunnableFuture<V>
```

而RunnableFuture是继承了Future和Runnable:
```
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

而在FutureTask中，run方法的代码是这样写死的：

```
public void run() {
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();         //注意看这一行代码
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
```

可以看到，其中run()方法调用了call()方法并返回了结果给result。

所以这样就可以知道，在使用的时候，FutureTask就类似一个包装，将Callable包装进去后，开启线程执行自己的run()方法，就会调用call()返回结果，这样就好理解，那么开启线程的思路和Runnable基本一样，可以这样实现：
```
FutureTask<Integer> futureTask = new FutureTask<Integer>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                return 10;
            }
        });

        new Thread(futureTask).start();
```

另一种写法自己上网看吧，这里就不贴了。

[Java并发编程：Callable、和FutureTask](http://www.cnblogs.com/dolphin0520/p/3949310.html)
[java 创建线程的三种方法Callable,Runnable，Thread比较及用法](http://www.2cto.com/kf/201310/250666.html)
[java线程：Callable和Future (讲的很详细)](http://blog.csdn.net/ghsau/article/details/7451464)

## JDK中默认提供了哪些线程池，有何区别

[Java四种线程池的使用](http://cuisuqiang.iteye.com/blog/2019372)
[java自带线程池和队列详细讲解](http://www.oschina.net/question/565065_86540)

## 线程同步有几种方式，分别阐述在项目中的用法
使用synchronized关键字
### 同步代码块

同步是一种高开销操作，所以如果在一个方法中，代码比较长，而需要同步的仅仅是一块比较短的代码，这个时候就可以使用同步代码块的方法。

```
Object o = new Object();
synchronized(o)
{
	//对o对象的操作或其他操作
}
```
或者

```
synchronized(this)
{
	//some code
}
```
### 同步方法

#### 同步静态方法

比如在Aclass中有一个静态方法是B

```
class A
{
	static synchronized void B()
    {
    	//some code
	}
}
```
这个时候，synchronized把A.class作为同步锁

#### 同步非静态方法

如果把上边的例子中的static去掉，这个时候同步的就是this,this在JAVA中指的就是实例化的对象。

还有一种，如果在class A中还有C方法，而C方法和B方法在运行时，需要操作同一个数据，并且如果不同步会出现问题，这个时候就可以在这两个方法上加上synchronized关键字，此时是把this作为同步锁。

### volatile关键字

Java 语言提供了一种稍弱的同步机制,即 volatile 变量.用来确保将变量的更新操作通知到其他线程,保证了新值能立即同步到主内存,以及每次使用前立即从主内存刷新. 当把变量声明为volatile类型后,编译器与运行时都会注意到这个变量是共享的.

想要理解volatile还需要理解原子操作，目前没有打算学这个，等到以后用到的时候再进行学习。

### LOCK和UNLOCK（同上）

## 自己实现线程池

(略)

# 字符相关

## String的不可变性

字符串的不可变性是指一旦某个字符串创建，对他的任何修改都会重新生成一个新的字符串。举个例子
如：String s = "abcd"; 在创建“abcd”时，如果内存堆中存在这个字符串，堆中就不会分配新的内存给这个字符串，而s直接就指向了”abcd”所在的地址。而如果不存在“abcd”，那么就会在堆中创建这个字符串。这个时候，如果又需要创建一个字符串为“abcd”,String s2 = "abcd";这个时候，s2和s的地址就是一样的。

在创建了一个字符串后，如果想要改变这个字符串，比如在该字符串的基础上添加一个字符，如s = s + 'a';，这时，不会改变”abcd”，而是在堆中重新分配内存给”abcda”。

这就是String的不变性。

```
String s = "abcd";
String s2 = "abcd";
System.out.println(s.hashCode() + "|" + s2.hashCode());
```

其中hashCode如果不重写，返回值就是某对象的地址。
如上测试代码的输出是：2987074|2987074

## StringBuilder和StringBuffer的区别

### 区别

在执行速度方面的比较：StringBuilder > StringBuffer
StringBuffer与StringBuilder，他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度就快了。
StringBuilder是线程非安全的，StringBuffer是线程安全的。当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。
### 对于三者使用的总结：

如果要操作少量的数据用 = String
单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
多线程操作字符串缓冲区 下操作大量数据 = StringBuffer
### 字符集的理解：Unicode、UTF-8、GB2312等

[十分钟搞清字符集和字符编码](http://blog.jobbole.com/84903/)
[字符集和字符编码](http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html)

## 正则表达式

[Java正则表达式入门](http://blog.csdn.net/kdnuggets/article/details/2526588)
[JAVA 正则表达式 （超详细）](http://blog.csdn.net/allwefantasy/article/details/3136570/)
[Java 正则表达式|菜鸟教程](http://www.runoob.com/java/java-regular-expressions.html)

# 注解

## 注解的使用,分级，以及自定义注解

在JAVA API中提供了两种注解，一种是标准注解，一种是元注解。

标准注解：@Override,@Deprecated,@SuppressWarnings

@Override:表示一个方法声明打算重写超类中的另一个方法声明。如果方法利用此注释类型进行注解但没有重写超类方法，则编译器会生成一条错误消息。
@Deprecated:用 @Deprecated 注释的程序元素，不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。在使用不被赞成的程序元素或在不被赞成的代码中执行重写时，编译器会发出警告。
@SuppressWarnings:指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示指定的编译器警告。注意，在给定元素中取消显示的警告集是所有包含元素中取消显示的警告的超集。例如，如果注释一个类来取消显示某个警告，同时注释一个方法来取消显示另一个警告，那么将在此方法中同时取消显示这两个警告。
元注解是JAVA API提供的，专门用来定义注解的注解。如：@Target,@Retention,@Documented,@Inherited就是元注解。

可以从java API中取得四种元注解的信息：

### @Targer:

指示注释类型所适用的程序元素的种类。如果注释类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。
必须元素为ElementType类型值：

|枚举值	|作用|
|--|--|
|ElementType.ANNOTATION_TYPE|	注释类型声明|
|ElementType.CONSTRUCTOR	|构造方法声明|
|ElementType.FIELD	|字段声明（包括枚举常量）|
|ElementType.LOCAL_VARIABLE|	局部变量声明|
|ElementType.METHOD	|方法声明|
|ElementType.PARAMETER	|参数声明|
|ElementType.TYPE	|类、接口（包括注释类型）或枚举声明|
|ElementType.PACKAGE	|包声明|
### @Retention

指示注释类型的注释要保留多久。如果注释类型声明中不存在 Retention 注释，则保留策略默认为 RetentionPolicy.CLASS。

|枚举值	|作用|
|--|--|
|RetentionPolicy.CLASS	|编译器将把注释记录在类文件中，但在运行时 VM 不需要保留注释。|
|RetentionPolicy.RUNTIME	|编译器将把注释记录在类文件中，在运行时 VM 将保留注释，因此可以反射性地读取。|
|RetentionPolicy.SOURCE	|编译器要丢弃的注释。|
### @Documented

指示某一类型的注释将通过 javadoc 和类似的默认工具进行文档化。应使用此类型来注释这些类型的声明：其注释会影响由其客户端注释的元素的使用。如果类型声明是用 Documented 来注释的，则其注释将成为注释元素的公共 API 的一部分。

### @Inherited

指示注释类型被自动继承。

### 注解的简单使用
直接看代码

```
import java.util.*;
import java.util.concurrent.*;
import java.lang.annotation.*;
class TestJava
{
    @TestA
    public static void main(String[] args)
    {
        String s = "abcd";
        String s2 = "abcd";
        System.out.println(s.hashCode() + "|" + s2.hashCode());
    }
    public @interface TestA{}
}
```
其中public @interface TestA()是定义的一个注解，这个注解是空注解，没有任何意义，从这里可以看出，定义注解需要使用@interface。
在上文中提到，元注解的作用是专门用来定义注解的注解，那么接下来看看如何使用元注解。

```
import java.util.*;
import java.util.concurrent.*;
import java.lang.annotation.*;
class TestJava
{
    @TestA
    public static void main(String[] args)
    {
        String s = "abcd";
        String s2 = "abcd";
        System.out.println(s.hashCode() + "|" + s2.hashCode());
    }
    @Target(ElementType.METHOD)
    public @interface TestA{}
}
```
如上列代码，在定义TestA注解的时候，为其加上元注解，元注解的值是ElementType.METHOD,表示该注解用于方法声明，同样，我们把ElementType.METHOD改为ElemntType.TYPE,再次编译后，就会运行出错，报错内容为：

TestJava.java:7: 错误: 注释类型不适用于该类型的声明
@TestA
^
1 个错误
这样就理解的@Target中参数的作用。

接下来看一个复杂的注解

```
@Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface TestA{
        String name();
        int id() default 0;
        Class gid();
    }
```
其中注解中的每一个方法名，就是该注解的参数名，而返回类型就是注解的参数的类型，如其中的String name()，就表示注解中第一个参数是name,类型是String,使用方法如：@TestA(name="Test",id=1,gid=Integer.class)

这样就知道注解是如何使用，那么如果有了注解，如何得到注解中的值呢？这就用到了反射机制，前面介绍过了反射机制

```
import java.util.*;
import java.util.concurrent.*;
import java.lang.annotation.*;
class TestJava
{
    public static void main(String[] args)
    {
        Class tmp = TMP.class;//得到TMP类
        Annotation[] annotations = tmp.getAnnotations(); //通过tmp这个类得到注解，这种方式得到的注解就是该类的注解，如果想要得到构造方法的注解，先要得到该类中的构造方法的对象Constructor，然后通过该对象再得到对应的注解
        for(Annotation a : annotations)
        {
            TestA t = (TestA)a;
            System.out.println(t.name() + "," + t.id() + "," + t.gid()); //得到注解的值
        }
    }
    @TestA(name="TMP",id=2,gid=Integer.class)  //使用注解
    class TMP
    {
        public void a()
        {
            System.out.println("Helloworld");
        }
    }
	//自定义注解
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)//注意此处一定要用该值，该值表示注解在运行时保留，如果用其他两个值，在运行时将没有注解，也就无法通过反编译得到该值
    public @interface TestA{
        String name();
        int id() default 0;
        Class gid();
    }
}
```
想学习更多注解知识，请参考以下博文，写的很详细：
[深入理解Java：注解（Annotation）基本概念](http://www.cnblogs.com/peida/archive/2013/04/23/3036035.html)
[深入理解Java：注解（Annotation）自定义注解入门](http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html)
[深入理解Java：注解（Annotation）–注解处理器](http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html)

# Android基础

终于到了安卓基础啦~其实学习JAVA的目的就是为了学习安卓，所以安卓的基础一定要打好，这很关键！嗯。

## Activity,Fragment的生命周期

这个问题是我自己想到加上去的，个人认为这个问题很基础而且很重要！

## Activity生命周期
![](/images/Activity生命周期.jpg)

启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。
当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。
当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。
当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。
用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。
当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。
用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。
## Fragment生命周期
![](/images/Fragment生命周期.png)
![](/images/两者对比图.png)

创建一个Fragment时，会依次调用onAttach(), onCreate() ,onCreateView(),onActivityCreated()
经历过onStart(),onResume()状态后，该Fragment便对用户可见。
当这个fragment进入后台时，或对用户不可见时，会调用onPause(),onStop()
当Fragment被销毁时onPause(),onStop(),onDestroyView(),onDestroy(),onDetach()
Fragment特有的状态：
onAttached() —— 当fragment被加入到activity时调用（在这个方法中可以获得所在的activity）。
onCreateView() —— 当activity要得到fragment的layout时，调用此方法，fragment在其中创建自己的layout(界面)。
onActivityCreated() —— 当activity的onCreated()方法返回后调用此方法
onDestroyView() —— 当fragment中的视图被移除的时候，调用这个方法。
onDetach() —— 当fragment和activity分离的时候，调用这个方法。
四大组件的意义及使用，生命周期回调及意义

# 安卓四大组件：Activity,Service,Broadcast Receiver,ContentProvider

## Activity

前边已经简述了Activity的生命周期，接着来看其启动模式

### Activity的四种启动模式

* standard:标准模式，系统默认模式，每次启动一个Activity都会创建一个实例，不论这个实例是否已经存在。
* singleTop:如果该Activity存在于任务栈栈顶，这个Activity就不会被重新创建，此时它的onCreate,onStart方法不会被调用，因为它并没有发生改变。如果该实例存在但不位于栈顶，那么就会创建一个新的实例。
* singleTask:只要Activity在一个栈中存在，那么多次启动该Activity都不会重新创建实例。如浏览器实现就需要使用该模式
* singleInstance:singleTask的加强版，拥有singleTask所有特性。唯一区别是，这个模式下Activity所处的任务栈中，只能有这个实例，不能有其他实例。
这些启动模式可以在AndroidMainfest中设置，即launchMode属性，也可以在Intent中设置标志，如

```
Intent intent = new Intent(MainActivity.this,SecondActivity.class);
intent.addFlag(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);
```

但是两种启动方式有区别的，首先，第二种启动方式比第一种启动方式优先级高，两者同时存在时，以第二种方式为主。然后，这两种方式的范围不同，比如第一种无法为Activity设置FLAG_ACTIVITY_CLEAR_TOP标识，第二种无法指定Activity为singleInstance模式。

[一些使用场景](http://www.android100.org/html/201606/06/241690.html)
### Activity的常用Flags

#### FLAG_ACTIVITY_NEW_TASK

为Activity指定为singleTask启动模式

#### FLAG_ACTIVITY_SINGLE_TOP

为Activity指定为singleTop启动模式

#### FLAG_ACTIVITY_CLEAR_TOP

具有该Flag的Activity，当启动时，在同一个任务栈中，位于他上面的Activity都要出栈。一般这个标记会和singleTask一起出现，singleTask启动模式，默认具有该效果。但是如果启动模式是standard，不仅他上面的Activity要出栈，他本身也要出栈，然后会创建一个新的该实例。

#### FLAG_ACTIVIYT_EXCLUDE_FROM_RECENTS

具有该标记的Activity不会出现在历史Activity的列表中,在好多手机上可以查看任务历史列表，如果指定了该FLAG，就不会在列表中出现。

## Service

Service是没有界面，运行在后台，不与用户进行交互的组件。每个service都要在AndroidMainfest中进行声明。

Service有两种状态，Started和Bound,即”销毁””绑定”。

Started : 通过startService()启动的服务处于‘启动’状态，一旦启动，就会在后台运行，即使启动它的组件被销毁(注意是组件被销毁，而不是线程)。通常Service执行单任务并且不返回任何结果给启动者，比如下载一个文件，当任务完成会自动结束。
Bound : 通过bindService()来启动。一个绑定的Service提供一个允许组件与Service交互的接口，可以发送请求，获取返回结果，还可以通过跨进程通信来交互。绑定的service只有在应用组件绑定后才能运行，多个组件可以绑定同一个service,当调用unbind()时，这个service就销毁了。
### Service的两种启动模式

#### startService()

　　本地服务 Local Service 用于应用程序内部。

　　它可以启动并运行，直至有人停止了它或它自己停止。在这种方式下，它以调用Context.startService()启动，而以调用Context.stopService()结束。它可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。不论调用了多少次startService()方法，你只需要调用一次stopService()来停止服务。

　　用于实现应用程序自己的一些耗时任务，比如查询升级信息，并不占用应用程序比如Activity所属线程，而是单开线程后台执行，这样用户体验比较好。

#### bindService()

　　远程服务 Remote Service 用于android系统内部的应用程序之间。

　　它可以通过自己定义并暴露出来的接口进行程序操作。客户端建立一个到服务对象的连接，并通过那个连接来调用服务。连接以调用Context.bindService()方法建立，以调用 Context.unbindService()关闭。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。

　　可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。

### 生命周期

![](/images/Service生命周期.png)
使用context.startService() 启动Service是会会经历:
context.startService() ->onCreate()- >onStartCommand()->Service running
context.stopService() | ->onDestroy() ->Service stop

如果Service还没有运行，则android先调用onCreate()然后调用onStartCommand()；如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。

stopService的时候直接onDestroy，如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。

所以调用startService的生命周期为：onCreate --> onStart(可多次调用) --> onDestroy
使用使用context.bindService()启动Service会经历：

context.bindService()->onCreate()->onBind()->Service running

onUnbind() -> onDestroy() ->Service stop

onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。这个时候把调用者（Context，例如Activity）会和Service绑定在一起，Context退出了，Srevice就会调用onUnbind->onDestroy相应退出。

所以调用bindService的生命周期为：onCreate --> onBind(只一次，不可多次绑定) --> onUnbind --> onDestory。
　　在Service每一次的开启关闭过程中，只有onStart可被多次调用(通过多次startService调用)，其他onCreate，onBind，onUnbind，onDestory在一个生命周期中只能被调用一次。

service生命周期也涉及一些回调方法如：
```
public class ExampleService extends Service {
    int mStartMode;       // indicates how to behave if the service is killed
    IBinder mBinder;      // interface for clients that bind
    boolean mAllowRebind; // indicates whether onRebind should be used
    @Override
    public void onCreate() {
        // The service is being created
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // The service is starting, due to a call to startService()
        return mStartMode;
    }
    @Override
    public IBinder onBind(Intent intent) {
        // A client is binding to the service with bindService()
        return mBinder;
    }
    @Override
    public boolean onUnbind(Intent intent) {
        // All clients have unbound with unbindService()
        return mAllowRebind;
    }
    @Override
    public void onRebind(Intent intent) {
        // A client is binding to the service with bindService(),
        // after onUnbind() has already been called
    }
    @Override
    public void onDestroy() {
        // The service is no longer used and is being destroyed
    }
}
```

### Service的优先级

1． 如果service正在调用onCreate,onStartCommand或者onDestory方法，那么用于当前service的进程则变为前台进程以避免被killed。
2． 如果当前service已经被启动(start)，拥有它的进程则比那些用户可见的进程优先级低一些，但是比那些不可见的进程更重要，这就意味着service一般不会被killed.
3． 如果客户端已经连接到service (bindService),那么拥有Service的进程则拥有最高的优先级，可以认为service是可见的。
4． 如果service可以使用startForeground(int, Notification)方法来将service设置为前台状态，那么系统就认为是对用户可见的，并不会在内存不足时killed。

### Service的使用

#### ##本地Service(不用与Activity交互的)

首先声明一个类继承Service并重写其中的方法，如果使用的AndroidStudio,直接建一个Service,AS会直接创建好，AndroidMainfest中都不用去声明。

```
class MyService extends Service{
	public MyService() {
    }
    @Override
    public IBinder onBind(Intent intent) {
        // TODO: Return the communication channel to the service.
        Log.i("-------","OnBind");
        return null;
    }
    @Override
    public void onCreate() {
        super.onCreate();
        Log.i("--------","onCreate");
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i("------","onStartCommand");
        return super.onStartCommand(intent, flags, startId);
    }
    @Override
    public void onStart(Intent intent, int startId) {
        super.onStart(intent, startId);
    }
}
```
注意Service中onStart()方法已被onStartCommand方法取代。

在AndroidMainfest中配置的Service为：

```
<service
            android:name=".MyService"
            android:enabled="true"
            android:exported="false"></service>
```

其中enabled表示是否允许被实例化，true为允许，如果为false,你将启动不了你的Service。
exported表示是否允许被Application的其他组件调用。

注意如果想要启动，一定要把enabled置为true

在手机中测试，第一次startService时，Log日志为

07-19 13:18:07.211 5936-5936/com.test.testandroid I/--------: onCreate
07-19 13:18:07.221 5936-5936/com.test.testandroid I/------: onStartCommand
第二次startService，并且连续三次startService,Log日志为

07-19 13:18:09.841 5936-5936/com.test.testandroid I/------: onStartCommand
07-19 13:18:11.041 5936-5936/com.test.testandroid I/------: onStartCommand
07-19 13:18:11.651 5936-5936/com.test.testandroid I/------: onStartCommand
由此可见，Service的onCreate只会调用一次，以后在运行Service时，会直接去调用onStartCommand.所以我们可以把service的逻辑任务写在startCommand中，注意如果是耗时操作，则需要开辟子线程来运行。

如果要停止该服务，可以使用Context.stopService(intent)或service.stopSelf()两种方式

#### 远程Service(可以和Activity交互)

与本地Service不同的是，远程需要用到onBind方法，并且在onBind方法中返回一个Binder。在bindService中，要传入一个ServiceConnection对象。

举个例子。

我们的MyService类

```
package com.test.testandroid;
import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.util.Log;
public class MyService extends Service {
    public MyService() {
    }
    class MyBinder extends Binder{
        public void myMethod()
        {
            Log.i("我想要执行的任务","-----------");
        }
    }
    @Override
    public IBinder onBind(Intent intent) {
        Log.i("-------","OnBind");
        return myBinder;
    }
    private MyBinder myBinder=  new MyBinder();
    @Override
    public void onCreate() {
        super.onCreate();
        Log.i("--------","onCreate");
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i("------","onStartCommand");
        return super.onStartCommand(intent, flags, startId);
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.i("-------","onDestroy");
    }
}
```
可以看到在onBind方法中返回了一个myBinder，而myBinder是定义在MyService中的内部类，在这个类中，我们可以定义我们自己的方法，这样在绑定后可以交给Activity去调用这些方法。

绑定前需要定义一个ServiceConnection对象

```
private ServiceConnection sc = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
        ((MyService.MyBinder)iBinder).myMethod();
    }
    @Override
    public void onServiceDisconnected(ComponentName componentName) {
        Log.i("---------","取消绑定");
    }
};
```
这里用了匿名类，来实例化了一个ServiceConnection对象，其中的onServiceConnected方法是在调用bindService的时候，即绑定时，会回调该方法，在该方法中可以得到MyService中的onBind方法返回的Binder对象，这样我们就可以在Activity中利用这个对象进行binder中的某些操作了。而onServiceDisconnectd并不是在unbindService的时候调用，官方给的解释是：当这个服务不是正常中断，而是意外被销毁，比如进程意外销毁的时候，onServiceDisconnected会调用，所以如果我们按正常操作来unbindService是看不到这个方法被调用的。

好了，接下来就是绑定，绑定方式为：bindService(intent,sc,Context.BIND_AUTO_CREATE);这样就实现了绑定，看下LOG日志

07-19 13:53:45.577 30567-30567/com.test.testandroid I/--------: onCreate
07-19 13:53:45.577 30567-30567/com.test.testandroid I/-------: OnBind
07-19 13:53:45.587 30567-30567/com.test.testandroid I/我想要执行的任务: -----------
可以看到，当bindService时，先实例化MyService后调用ServiceConnection中的onServiceConnected。
而调用unbindService会打印日志：

07-19 13:55:12.107 30567-30567/com.test.testandroid I/-------: onDestroy
可以看到，只会调用MyService中的onDestroy方法，而ServiceConnection中的onServiceDisconnected方法不会被调用。

#### 使用前台服务

前台服务与普通服务的最大区别是，它会一直有一个正在运行的图标在系统的状态显示。比如墨迹天气的天气显示。如何创建一个前台服务呢，只需要在服务创建的时候(onCreate)调用startForeground()方法，当然需要参数Notification。

如

```
public void onCreate() {
    super.onCreate();
    Intent intent = new Intent(this,MainActivity.class);
    PendingIntent p = PendingIntent.getActivity(this,0,intent,0);
    Notification notification = null;
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN) {
        notification = new Notification.Builder(getApplicationContext())
                .setContentTitle("我是一个前台服务")
                .setSmallIcon(android.R.drawable.ic_dialog_email)
                .setContentText("哈哈哈哈")
                .setContentIntent(p)
                .build();
    }
    startForeground(1,notification);
    Log.i("--------","onCreate");
}
```
当创建了Service时，就会在通知栏显示通知。

#### 使用IntentService

Service是运行在主线程中的，如果要在service中执行耗时操作，需要开辟一个子线程如

```
class MyService extends Service
{
	...
    
    @Override
    public int onStartCommand(Intent intent,int flags,int startId){
    	new Thread(new Runnable(){
        	@Override
            public void run()
            {
            	//some code
                
                stopSelf();//执行完毕要关闭该服务
            }
        }).start();
        return super.onStartCommand(intent,flags,startId);
    }
    
    ...
}
```
同样，安卓也提供了一个IntentService类，这个类继承于Service，目的是解决耗时操作在Service运行，并且运行完毕能够自动停止。启动方式和启动Service的启动方式一样，不过可以启动多次IntentService,而每一个耗时操作会以工作队列的方式在IntentService的onHandlerIntent回调方法中执行，并且每次只执行一个工作线程。

使用方法如下：

```
public class MyIntentService extends IntentService {
    public MyIntentService() {
        super("MyIntentService");
    }
    @Override
    protected void onHandleIntent(Intent intent) {
        if (intent != null) {
            final String action = intent.getAction();
            if(action.equals("FirstAction"))
            {
                Log.i("-------","FirstAction");
            }else if(action.equals("SecondAction"))
            {
                Log.i("-------","SecondAction");
            }
        }
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void onCreate() {
        super.onCreate();
        Log.i("------","onCreate");
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i("------","onStartCommand");
        return super.onStartCommand(intent, flags, startId);
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.i("---------","onDestroy");
    }
}
```
要继承IntentService，主要回调onHandlerIntent方法，其中该方法的Intent参数是在调用startService时传递过来的参数，可以根据intent的不同执行不同的操作。

随后可以启动该Service

```
Intent intent = new Intent(MainActivity.this,MyIntentService.class);
intent.setAction("FirstAction");
startService(intent);
intent.setAction("SecondAction");
startService(intent);
```
可以查看打印日志的内容

07-19 11:26:43.673 8304-8304/com.test.testandroid I/------: onCreate
07-19 11:26:43.674 8304-8304/com.test.testandroid I/------: onStartCommand
07-19 11:26:43.674 8304-8304/com.test.testandroid I/------: onStartCommand
07-19 11:26:43.676 8304-8337/com.test.testandroid I/-------: FirstAction
07-19 11:26:46.685 8304-8337/com.test.testandroid I/-------: SecondAction
07-19 11:26:49.688 8304-8304/com.test.testandroid I/---------: onDestroy
可以看到，其中的onCreate只执行了一次，而当调用了startService时就会执行onStartCommand。从打印日志中看，SecondAction比FirstAction晚3秒才打印，这就说明了只有一个IntentService实例。在完成任务时就会destroy.

## BroadcastReceiver

广播接受者，用来接受发出的广播Intent
安卓中的广播分为两种：标准广播和有序广播

标准广播，是一种完全异步执行的广播，在广播发出后，所有广播接收器几乎会在同一时间接收到这条广播。
有序广播，同步执行广播，广播发出后同一时间只有一个广播接收器接受，而顺序跟广播优先级有关，在广播接收器接受后会发给下一个广播接收器，当然也可以选择截断广播。
安卓系统内置了很多广播，例如电量低的时候会发送一条广播，网络状态切换时会发送一条广播等

我们可以通过例子来认识广播，自定义一个广播继承自BroadcastReceiver并实现其onReceive方法，注意广播没有提供可视化界面，但是我们可以通过Notification来显示相关信息。

```
public class MyReceiver extends BroadcastReceiver {
    public MyReceiver() {
    }
    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i("--------",intent.getAction().toString());
    }
}
```
但是我们怎么确保这个广播接收器可以接受到某一个广播呢？这个时候就需要我们为广播注册地址，只有注册了广播，该广播才能够使用。

注册方式有两种：静态注册，动态注册

### 静态注册

在AndroidMainfest中为receiver注册

```
<receiver
    android:name=".MyReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED"/>
        <category android:name="android.intent.category.DEFAULT"/>
    </intent-filter>
    </receiver>
```
注意要为其添加intent-filter，即过滤器，不然那么多广播，到底是让其接受哪个呢。这样只要系统发出android.intent.action.BOOT_COMPLETED这条广播，MyReceiver都能接受到，这条广播是系统开机完成后发出的，不过这种注册方式是常驻型的，即使所属的App被销毁了，只要系统发出这条广播，广播接收器都能接受到，所以这种类型的广播可以实现开机启动,但是我们要给程序添加接受开机广播的权限<user-permission android:name="android.permission.RECEIVER_BOOT_COMPLETED"。当然获得广播后，就可以通过context启动服务等等自己想做的事啦。

### 动态注册

需要在代码中为一个广播接受者注册地址，通常在Activity或者Service为Receiver注册。
```
MyReceiver receiver = new MyReceiver();
IntentFilter filter = new IntentFilter();
filter.addAction("android.intent.action.CUSTOME_ACTION");
registerReceiver(reveiver,filter);
```
但是我们必须要在Activity销毁前解除注册，如在onDestroy中解除

```
@Override
public void onDestroy()
{
	super.onDestroy();
    unregisterReceiver(receiver);
}
```
动态注册的生命周期刚好与静态注册的相反，动态注册的广播接收器，只有在APP存在且未被销毁才能接受广播。

### 发送广播

使用sendBroadcast(intent)
如

```
Intent intent = new Intent("android.intent.action.CUSTOME_ACTION");
sendBroadcast(intent);
```
这样就发送了一条广播，但是发送的是普通广播，如果想发送有序广播，需要使用sendOrderedBroadcast，这个方法有第二个参数，即一个权限参数–>[了解安卓声明和使用权限](http://blog.csdn.net/liuhe688/article/details/6417983)

如果要给不同的Receiver定义不同的权限，需要使用到priority属性，这个属性位于intent-filter中
如

```
<intent-filter android:priority="999">
	...
</intent-filter>
```
## ContentProvider

内容提供者，主要用于对外共享数据。通过ContentProvider把应用中的数据共享给其他应用访问，其他应用可以通过ContentProvider对指定的应用的数据进行操作。比如我们要操作手机中的联系人就可以使用ContentProvider。安卓已经默认为一些常见的数据提供了ContentProvider(包括音频，视频，图片和通讯录等)。

### ContentResolver

如果要访问ContentProvider共享的数据，需要借助于ContentResolver,可以通过Context的getContentResolver()方法获取到该类的实例。ContentResolver提供过来一系列的方法用于对数据的CRUD操作。使用ContentResolver之前要先了解什么是URI，因为ContentResolver的一些方法要传入uri参数

#### uri

uri由于两部分组成，权限和路径。权限是为了区分不同的应用程序，一般用包名来做为权限，比如某个包名是com.example.app,那么权限就是com.example.app.provider。而路径是用于对数据中不同的表作区分，通常添加到权限后边，比如某个程序的数据库里面存在两张表table1,table2，这个时候路径就可以为/table1,/table2,将权限和路径组合，即为com.example.app/table1，这样还不能组成uri,还需要在前边加上协议content://，所以一个标准的uri写法为：content://com.example.app/table1
对于一个uri能很清楚的表达出我们想要访问哪个程序的哪个表。

这样，我们就可以同过ContentResolver来访问某个程序中某个表中的数据了，如

```
Cursor cursor = getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder);
```
参数说明

|query()方法参数|	对应Sql部分|	描述|
|---|---|---|
|uri|	from table_name	|指定查询某个应用程序下的某一张表|
|projection|	select column1,column2	|指定查询的列名|
|selection	|where column = value	|指定where的约束条件
|selecttionArgs	|-	|为where中的占位符提供具体的值|
|orderBy	|order by column1,column2	|指定查询结果的排序方式|

查询完成后返回的是一个Cursor对象，这样我们就可以从Cursor中依次读取数据了。读取思路，是先读取每一行，然后读取每一列

```
if(cursor!=null)
{
	while(cursor.moveToNext())
    {
    	String column1 = cursor.getString(cursor.getColumnIndex("column1"));
        int column2 = cursor.getString(cursor.getColumnIndex("column2"));
    }
    cursor.close();
}
```
添加数据

```
ContentValues values = new ContentValues();
values.put("column1","text");
values.put("column2",2);
getContentResolver.insert(uri,values);
```
对于其他方法如update，可以查询API，这里不再赘述。

如果想要实现提供数据给其他应用，可以编写类继承ContentProvider并重写其中的方法。想要了解更多请自行百度，因为目前做开发的时候用到的比较少，所以没有很仔细的研究。

## AsyncTask、Handler的使用

### Handler介绍

一、Handler主要接受子线程发送的数据(比如handler.post(runnable)，在runnable中运行的结果给handler)， 并用此数据配合主线程更新UI.
当应用程序启动时，Android首先会开启一个主线程, 主线程为管理界面中的UI控件，进行事件分发,更新UI只能在主线程中更新，子线程中操作是危险的。这个时候，Handler就需要出来解决这个复杂的问题。由于Handler运行在主线程中(UI线程中),它与子线程可以通过Message对象来传递数据, 这个时候，Handler就承担着接受子线程传过来的(子线程用sendMessage()方法传递)Message对象(里面包含数据), 把这些消息放入主线程队列中，配合主线程进行更新UI。
二、Handler的特点
Handler可以分发Message对象和Runnable对象到主线程中, 每个Handler实例,都会绑定到创建他的线程中,
它有两个作用:
(1)安排消息或Runnable 在某个主线程中某个地方执行
(2)安排一个动作在不同的线程中执行
Handler中分发消息的一些方法
post(Runnable)
postAtTime(Runnable,long)
postDelayed(Runnable,long)
sendEmptyMessage(int)
sendMessage(Message)
sendMessageAtTime(Message,long)
sendMessageDelayed(Message,long)
以上post类方法允许你排列一个Runnable对象到主线程队列中,
sendMessage类方法, 允许你安排一个带数据的Message对象到队列中，等待更新.

### Handler异步实现的原理和适用的优缺点

在Handler 异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程），Thread(子线程)运行并生成Message- Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。

使用的优点：
l 结构清晰，功能定义明确
l 对于多个后台任务时，简单，清晰

### Handler的使用

用handler方式处理需要知道与handler相关的几个组件，Looper和Queue,其实Looper的作用就是把handler发送的消息放 到MessageQueue中，并把消息广播给所有与这个MessageQueue相关的handler，而Queue一般是主线程开启的时候就给这个线程分配了一个，所以你要与UI 主线程通信必须用于这个Queue相关联的handler对象才行，一般handler对象在那个线程中创建的就与那个线程的queue关联，所以在UI 线程中创建的handler对象就与UI线程通讯，这样我们就可以在子线程中发送消息给主线程，实现更新UI的功能。那主线程又是怎么处理子线程发送的消 息的呢？其实在生成handler对象的时候我们就要实现handler对象的handleMessage（）方法这个方法就是主线程接受并处理子线程发 送过来的消息的方法，从而实现 更新UI线程的功能。

即通过Thread进行子线程的耗时操作，在操作完成之后，使用handler的sendMessage将消息发送给handler，handler随后调用handlerMessage方法来更新UI。

来看下代码：

```
public class MainActivity extends AppCompatActivity {
    private Handler handler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            Log.i("--------",""+msg.what);
            //这里可以更新UI
            super.handleMessage(msg);
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        findViewById(R.id.btn1).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //一些耗时操作
                        try {
                            Thread.sleep(3000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        handler.sendEmptyMessage(0);
                    }
                }).start();
            }
        });
    }
}
```
handler不仅可以得到子线程中的操作结果更新UI，还可以将指定任务发送到任务队列。
即使用handler.post(runnable)方法。

### AsyncTask介绍

Android的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。
首先明确Android之所以有Handler和AsyncTask，都是为了不阻塞主线程（UI线程），且UI的更新只能在主线程中完成，因此异步处理是不可避免的。

Android为了降低这个开发难度，提供了AsyncTask。AsyncTask就是一个封装过的后台任务类，顾名思义就是异步任务。
AsyncTask直接继承于Object类，位置为android.os.AsyncTask。要使用AsyncTask工作我们要提供三个泛型参数，并重载几个方法(至少重载一个)。

AsyncTask定义了三种泛型类型 Params，Progress和Result。

Params 启动任务执行的输入参数，比如HTTP请求的URL。
Progress 后台任务执行的百分比。
Result 后台执行任务最终返回的结果，比如String。
使用AsyncTask必须要重写的方法是doInBackground：

doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。
onPostExecute(Result) 相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回
可以重写以下这三个方法，但不是必须的：
onProgressUpdate(Progress…) 可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。
onPreExecute() 这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。
onCancelled() 用户调用取消时，要做的操作
使用AsyncTask类，以下是几条必须遵守的准则：

Task的实例必须在UI thread中创建；
execute方法必须在UI thread中调用；
不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params…), onProgressUpdate(Progress…)这几个方法；
该task只能被执行一次，否则多次调用时将会出现异常；
### AsyncTask实现的原理和适用的优缺点

AsyncTask,是android提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程.

使用的优点:
l 简单,快捷
l 过程可控

使用的缺点:
l 在使用多个异步操作和并需要进行Ui变更时,就变得复杂起来.

### 使用AsyncTask

前边已经介绍过了AsyncTask的构成，那么使用就比较简单了。

```
class MyAsyncTask extends AsyncTask<Void,Integer,String>
{
    @Override
    protected void onPreExecute() {
        //准备方法，比如可以在UI中显示一个进度条等
        super.onPreExecute();
    }
    @Override
    protected String doInBackground(Void... voids) {
        //后台耗时操作，如果想要在某个时间更新UI，而不仅仅得到结果更新UI，可以使用publishProgress方法，参数是指定的第二个类型的参数
        return null;
    }
    //当调用publishProgress()方法时，会调用onProgressUpdate方法，同样该方法在UI线程中运行，可以更新UI
    @Override
    protected void onProgressUpdate(Integer... values) {
        super.onProgressUpdate(values);
    }
    //运行完毕后会调用该方法，其中参数就是doInBackground返回的结果
    @Override
    protected void onPostExecute(String s) {
        super.onPostExecute(s);
    }
}
```
定义了一个AsyncTask之后，就可以在主线程中调用new MyAsyncTask().execute()启动，如果需要传递参数，则可以将参数放到execute()中。

## 利用handler实现循环执行某一任务，或者按时监听某个任务执行状态

第一种方式，利用handler的postDelayed(Runnable r,long time)方法
该方法的意思是，延迟time时间后，执行r中的方法。那么我们可以有这么一种思路，当执行r中的run()方法，在run()方法中，依然使用handler将r延时post出去，post出去后接着执行r中的run()方法，这样就实现了循环模式。

讲不清楚直接看代码：

```
private Handler handler = new Handler();
Runnable task = new Runnable() {
    @Override
    public void run() {
        Log.i("-------",new SimpleDateFormat("ss").format(System.currentTimeMillis()));//打印时间
        //other code
        handler.postDelayed(task,1000);
    }
};

```
在Activity中的某处，直接调用handler.postDelayed(task,1000);即开始了循环模式,注意这个不是在子线程中执行！不是！不是！handler的post的含义是把一个runnable中的代码传递到主线程中去，即可以在runnable中写更新UI的操作，post之后，就会在主线程中运行，所以你在runnable中打印当前线程，会发现打印的是主线程！

如果我们要实现一个ViewPager中的图片轮播模式，我们可以用这种方式，循环的将图片滚动到下一张，这种方式不是耗时操作，所以不会阻塞线程。

第二种，利用handler的sendMessage方法

handler在发出消息后，会调用该对象中的hanlerMessage来处理该消息，在处理完成后，继续发送消息即可实现循环操作。

直接看代码：

```
private Handler handler = new Handler()
   {
   	@Override
       public void handleMessage(Message msg)
       {
       	//some code
           handler.sendEmptyMessageDelayed(0,2000);
       }
   }
```
这种方式的循环处理，会一直在主线程中处理，可以更新UI界面。

对于上面两种方法，有个缺陷是如果要执行耗时操作，肯定是不行的，因为都运行在子线程中，不过我们可以通过HanderThread,得到一个子线程，并将HandlerThread的Looper传递给该Handler，其他代码保持不变，这样循环运行的代码就是在子线程中
```
private HandlerThread handlerThread = new HandlerThread("qxg");
handlerThread.start(); //注意一定要start()否则会报错
private Handler handler = new Handler(handlerThread.getLooper()) //注意此处一定要将Looper传递过去，否则还会在主线程中运行
{
  //...
}
```
第三种方式：
现在我们有一个需求，要求在子线程中循环执行某一操作，在循环一次后都要在主线程中更新UI。但是上面的两种方法都只能在主线程完成，除非我们在循环执行的时候开辟子线程执行任务，但是这样又不能更新我们的UI。所以，我们可以换种思路，利用handlerThread在子线程循环执行某一操作，操作执行完后，利用与主线程绑定的hander将更新UI的代码post出去。

直接看代码：

```
mHandler = new Handler();
private HandlerThread ht = new HandlerThread("qxg");
handler = new Handler(ht.getLooper()){
    int i= 0;
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        Log.i("--------",""+Thread.currentThread().toString());
        //这里执行循环的操作
        //操作完成后利用mHandler去更新UI
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                i++;
                btn.setText("哈哈哈"+i);
            }
        });
        handler.sendEmptyMessageDelayed(0,2000);
    }
};
```
当然我们更新UI不仅仅可以使用mHandler.post的方式，同样也可以使用sendMessage的方式。

## Android系统层次框架结构
![](/images/安卓系统架构.png)

### Linux内核层

安卓系统是基于Linux2.6内核的，这一层为安卓设备的各种硬件提供了底层的驱动，如显示驱动，音频驱动，照相机驱动，蓝牙驱动，Wifi驱动，电源管理等。

### 系统运行库层

这一层通过C/C++库来为安卓系统提供了主要的特性支持，如SQLite库提供了数据库的支持，OpenGL|ES库提供了3D绘图的支持，Webkit库提供浏览器内核的支持等。
在这一层还有一个Android运行时库，它主要提供一些核心库，能够允许开发者使用JAVA语言编写Android应用。另外，安卓运行时库还包括了Dalvik虚拟机实例，相较于JAVA虚拟机，Dalvik是专门为移动设备定制的，它针对手机内存，CPU性能等做了优化处理。

### 应用框架层

这一层主要提供了构建应用程序时可能用到的各种API，Android 自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。

### 应用层

所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从Google Play 上下载的小游戏，当然还包括你自己开发的程序。

## AsyncTask的实现方式

我们进入AsyncTask源码中探探究竟，如果不知道怎么查看源码，可以[戳此](http://www.qxgzone.com/2017/01/09/%E5%AE%89%E5%8D%93%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81%E6%96%B9%E5%BC%8F/)查看方法。
我们知道在我们编写类继承AsyncTask，其运行的入口在excute()，所以我们先看AsynTask中的excute方法

```
public final AsyncTask<Params, Progress, Result> execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}
```
可以看到其调用了executeOnExecutor方法其中传递了一个sDefaultExecutro，是AsyncTask默认的一个SerialExecutor，这里不进行研究，接着我们查看executeOnExecutor方法

```
public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,
        Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException("Cannot execute task:"
                        + " the task is already running.");
            case FINISHED:
                throw new IllegalStateException("Cannot execute task:"
                        + " the task has already been executed "
                        + "(a task can be executed only once)");
        }
    }
    mStatus = Status.RUNNING;
    onPreExecute();
    mWorker.mParams = params;
    exec.execute(mFuture);
    return this;
}
```
可以看到，该方法首先验证该异步任务是否正在运行，或者是否已经运行结束，如果是会抛异常，如果没有执行，则将状态变量置为RUNNING状态，随后调用onPreExecute()方法，即准备方法，接着通过默认的SerialExecutor对象exec调用方法execute，我们肯定会纳闷这个mFuture是什么对象，那么接着看源码：

```
mFuture = new FutureTask`<Result>(mWorker) {
            @Override
            protected void done() {
                try {
                    postResultIfNotInvoked(get());
                } catch (InterruptedException e) {
                    android.util.Log.w(LOG_TAG, e);
                } catch (ExecutionException e) {
                    throw new RuntimeException("An error occurred while executing doInBackground()",
                            e.getCause());
                } catch (CancellationException e) {
                    postResultIfNotInvoked(null);
                }
            }
        };
```
可以看到,其中的mFuture是一个FutureTask对象,而FutureTask是一个RunnableFuture对象，RunnableFuture又继承于Future和Runnable，所以FutureTask既可以作为Runnable也可以作为Future，简单理解下，JAVA中执行异步操作使用的是Runnable,Thread，然后这种方法是无法获取到执行结果的，所以出现了Future和Callable，其中Callable进行异步操作，Future对象用于获取执行结果。使用方法可以查看最上面的JAVA文章，上面贴的链接，讲解也很详细。

好了，继续看，mFuture初始化时传递了mWorker对象，mWorker对象就是我们要执行的异步操作，而重写的done方法的含义是，当mWorker异步操作执行完毕后，执行该done()操作。

那么接下来我们就去看看mWorker对象。

```
mWorker = new WorkerRunnable`<Params, Result>() {
            public Result call() throws Exception {
                mTaskInvoked.set(true);
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                //noinspection unchecked
                Result result = doInBackground(mParams);
                Binder.flushPendingCommands();
                return postResult(result);
            }
        };
```
```
private static abstract class WorkerRunnable`<Params, Result> implements Callable<Result> {
        Params[] mParams;
    }
```
其实mWorker和mFuture都是在构造函数中被赋值的，这里可以看到，mWorker是一个WorkerRunnable对象,而WorkerRunnable是AsyncTask的内部类，其实现了Callable接口，并添加了Params数组参数。说白了，mWorker是一个实现了Callable接口的对象，我们看其中的call方法，其首先将mTaskInvoked设置为true(不必深究mTaskInvoked.set()的含义，只需要记住这里给其设置为true就行)，利用Process设置线程的优先级，参数值为10，其中19为最低优先级，这个了解一下就行了。接着往下看就会发现，在mWorker中调用了doInBackground()，并且返回postResult(result)。这个时候查看postResult()方法

```
private Result postResult(Result result) {
       @SuppressWarnings("unchecked")
       Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
               new AsyncTaskResult<Result>(this, result));
       message.sendToTarget();
       return result;
   }
```
在postResult内部，首先使用getHandler来获取一个Handler对象，并传递一个消息,其中message.what = MESSAGE_POST_RESULT,message.obj = new AsyncTaskResult\(this,result),实例化消息后，就将消息发了出去，那么有了消息，一定有handler，有handler就会存在消息处理即handlerMessage,我们查看代码发现，getHandler使用的单例模式，为sHandler构造InternalHandler对象，所以我们看InternalHandler中的handleMessage方法。

```
public void handleMessage(Message msg) {
            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;
            switch (msg.what) {
                case MESSAGE_POST_RESULT:
                    // There is only one result
                    result.mTask.finish(result.mData[0]);
                    break;
                case MESSAGE_POST_PROGRESS:
                    result.mTask.onProgressUpdate(result.mData);
                    break;
            }
        }
```
这里，当message.sendToTarget()发出消息后，handleMessage中的方法就会调用，其中首先获取的是消息中的AsyncTaskResult对象，最后调用了result.mTask.finish(result.mData[0])方法，这里解释一下，result.mTask其实就是我们的AsyncTask对象本身，所以最终调用的是我们的AsyncTask对象中的finish方法。

```
private void finish(Result result) {
    if (isCancelled()) {
        onCancelled(result);
    } else {
        onPostExecute(result);
    }
    mStatus = Status.FINISHED;
}
```
在finish中可以看到，最终调用了onPostExecute()方法。

这样就理清了AsyncTask的工作思路，当我们调用AsyncTask对象的execute方法时，会默认调用内置的executeOnExecutor方法，在该方法中，首先调用onPreExecute()，注意，这个方法并没有使用到异步机制，所以是在主线程中运行的，接着调用exec.execute(mFuture)，这个时候就开始了异步操作，首先mFuture是一个FutureTask操作，在实例化的时候传递了mWorker，mWorker是一个Callable对象，当调用了exec.execute(mFuture)，就开始执行mWorker中的call()方法中的操作，这个时候就进入了子线程中工作，执行完毕后，调用postResult方法使用Message对象传递消息，而该消息携带的参数有标志参数以及一个AsyncTaskResult对象，而AsyncTaskResult只是一个携带着AsyncTask对象以及其他参数的类而已，没有多么复杂，传递完消息后，就会在handler中得到消息并执行handleMessage操作，而onPostExecute()操作正是在handleMessage操作中执行的。这个时候看mFuture中的done()方法，因为mWorker已经执行完毕，所以done()就会被调用。done()中的内容不多，所以这里不再赘述了。

其大致工作流程图为下，总结的可能不全，望改正。
![](/images/AsyncTask工作流程.png)

最后，我们可以知道，AsyncTask，不仅用到Handler,Message等处理机制，还用到了JAVA中的Future,Callable的异步处理机制。而其中的doInBackground正是在Callable中执行的，而并不是使用Runnable实现的。

如果看完还不是很懂，可以看鸿洋大神的文章：Android AsyncTask 源码解析

## AsyncTask使用的时候应该注意什么

1.从源码中可以看到，如果AsyncTask正在运行，或者运行结束了，再次运行就会抛出异常，所以AsyncTask只能运行一次。
2.我们的AsyncTask可能需要更新我们的UI，但是如果在更新前，我们的Activity销毁了，但是AsyncTask的doInBackground依然会执行，如果执行完毕后，需要更新UI，因为我们的View已经被销毁了，所以就会崩溃。所以我们在View销毁前记得调用方法取消AsyncTask的执行。
3.AsyncTask如果为某个Activity的内部类，他会保留一个对该Activity的引用，如果Activity被销毁，后台进程还在执行，而Activity依然会存在于内存中，这样就导致了内存泄漏的问题。
4.当我们取消掉了AsyncTask任务时，doInBackground任务还是会执行，只是不执行onPostExecute以及publishProgress方法罢了,同样，不执行publishProgress方法也就不执行onProgressUpdate方法。所以如果我们的doInBackgound操作是一种循环操作，并且耗时，我们可以设置一个标记位，或者直接通过isCancelled来判断是否被取消，如果被取消，就在doInBackground中断操作，如果没被取消则继续执行。

## Android常见的存储方式

安卓中有四种存储方式：SharedPreferences，File，SQLite,ContentProvider

### SharedPreferences

该存储方式实际上存储的一种基于XML文件的”key-value“的数据，我们可以用他来存储一些程序的配置信息。

存储目录位于data/data/<包名>/shared_prefs/目录下。

#### 存储数据

存储的数据是通过键值对来保存的，这样我们存进去的数据也可以通键来取得其值。

如果想要通过SharedPreferences来存储数据，首先就是获取SharedPreferences对象。安卓中有三种方式可以得到该对象。

1. Context中的getSharedPreferences()
该方法接收2个参数，第一个指定名称，如果不存在便会创建一个该文件，第二个指定指定操作模式，MODE_PRIVATE,MODE_MULTI_PROCESS,第一个模式为默认模式，表示只有当前的应用程序才可以对文件进行读写操作，第二种模式用于多个进程对该文件操作。
2. Activity的getPreferences()该方法只接受一个模式参数，调用该方法时，他会自动将当前活动的类名(getLocalClassName())作为SharedPreferences的文件名，比如在MainActivity中调用的，文件名就为MainActivity.
3. PreferceManger类中的getDefaultSharedPreferences()，接受一个Context参数，并自动使用当前应用的包名作为前缀来命名SharedPreferences文件。

得到SharedPreferences对象后就可以存储数据，存储数据过程为：获取SharedPreferences的Editor对象–>向Editor对象中添加数据–>调用commit()将数据提交。

举个例子就明白其使用方式了。

```
SharedPreferences.Editor editor = getSharedPreferences("test",MODE_PRIVATE).edit();
editor.putString("test_string","helloworld");
editor.putBoolean("boolean",true);
editor.putFloat("float",1.5f);
editor.putInt("Int",5);
editor.putLong("long",555);
editor.putStringSet("Set\<String>",new HashSet\<String>());
editor.commit();
```
#### 获取数据

获取方法比存储方法容易，只需要获取SharedPreferences对象，通过该对象的一系列的get方法即可获取对应的键值数据。

如

```
SharedPreferences pref = getSharedPreferences("test",MODE_PRIVATE);
pref.getString("test_string","haha"); //第二个参数为默认值
```
### File

采用文件存储的方式，Context提供了openFileOutput()方法，可以将数据存储到指定的文件中，该方法接受两个参数，第一个参数为文件名，第二个参数是文件的操作模式，使用这种方式，都是把文件存放到/data/data/<包名>/files/下的。其操作模式主要有两种：MODE_PRIVATE,MODE_APPEND,第一种为默认的操作模式，表示当有同名文件存在，会覆盖掉其文件，而第二种是追加模式。

openFileOutput方法返回的是一个FileOutputStream对象，得到该对象就可以使用JAVA流中的操作方式对文件进行操作了。

而如果我们想要获取文件的输入流，只需要调用openFileInput()方法即可，该方法传递一个参数，即文件名，该方法同样返回一个FileInputStream对象。

### SQLite

SQLite是安卓内置的数据库，是一款轻量级的关系型数据库

#### 创建数据库

为了方便管理数据库，安卓提供了一个SQLiteOpenHelper类，借助该类，我们可以对数据库进行简单的创建和升级。注意，可以升级。SQLiteOpenHelper是一个抽象类，所以如果要使用该类，我们要创建一个类来继承它，并重写其中的onCreate()和onUpgrade()。

该类有两个比较重要的方法，getReadableDatabase()和getWritableDatabase()，这两个方法都可以创建或打开一个现有的数据库(如果不存在，则会创建一个数据库，创建过程后面讲)，并返回一个相应的读写操作的对象。getReadableDatabase()返回一个只读数据库的对象，而getWritableDatabase()返回一个可写的操作数据库的对象，但是如果数据库空间不足，该对象会抛出异常。

SQLiteOpenHelper构造方法拥有四个参数，第一个是Context,第二个是数据库名，第三个允许我们在查询数据库返回自定义Cursor,这里传入null即可，第四个表示当前数据库的版本号。注意这里的版本号会影响其是否调用onUpgrade()方法。

如果我们要使用SQLite，首先要构建出SQLiteOpenHelper对象，构建出后，调用getXXXXDatabase()就可以创建数据库(数据库不存在),数据库文件会存在于/data/data/<包名>/databases/目录下。创建数据库会调用onCreate()方法，所以一般在这里编写创建表的逻辑。

说的多也不如看代码：

```
public class MySqlOpenHelper extends SQLiteOpenHelper {
    private static final String CREATE_CAR = "CREATE TABLE CAR("
            +"id integer primary key autoincrement,"
            +"color nchar(2),"
            +"size nchar(2),"
            +"name nchar(5))";
    public MySqlOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
        super(context, name, factory, version);
    }
    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(CREATE_CAR);
    }
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    }
}
```
如上，在onCreate()中创建了一个表，创建过程通过onCreate的参数SQLiteDatabase db来创建。

```
MySqlOpenHelper helper = new MySqlOpenHelper(this,"SqlName",null,1);
SQLiteDatabase db = helper.getWritableDatabase();
```
接着通过上述代码即可完成创建。

#### 升级数据库

升级数据库于onUpgrade方法关联。

比如我们在第一次调用的时候传入的版本号是1，而如果第二次调用传入版本号是2，这个时候就不会执行onCreate操作，因为onCreate中创建的数据库已经存在了。注意我们在填入的版本号是必须大于1的，不然会报异常。

这里我们可以查看源码，就能明白其中的逻辑了

```
final int version = db.getVersion();
if (version != mNewVersion) {
    if (db.isReadOnly()) {
        throw new SQLiteException("Can't upgrade read-only database from version " +
                db.getVersion() + " to " + mNewVersion + ": " + mName);
    }
    db.beginTransaction();
    try {
        if (version == 0) {
            onCreate(db);
        } else {
            if (version > mNewVersion) {
                onDowngrade(db, version, mNewVersion);
            } else {
                onUpgrade(db, version, mNewVersion);
            }
        }
        db.setVersion(mNewVersion);
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}
```
在没有创建过数据库时，db.getVersion得到的值是0，这个时候，会执行onCreate()方法来创建数据库，并把当前version设置为传入的mNewVersion,下次在调用getVersion时，返回的值就是当前数据库版本号的值。

如果我们想要更新数据库，但是传入版本号的值依然是1，查看源码可以知道，我们什么也不会做。而如果我们传入版本号是2，其会调用onUpgrade方法，不会调用onCreate方法，因为当前数据库的版本号是存在且不为0的。所以可以知道onUpgrade方法是于数据库版本号挂钩的。

虽然知道这些，但是升级会有很多问题，比如我们可以把原数据库删除，并重新创建新的数据库，这也是一种升级方式，但是我们之前保存的数据都会消失。我们有一个很好的方法对数据库进行升级。

代码如下：

```
onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion)
{
	switch(oldVersion)
    {
    	case 1: //这里填写从version1到下一个version更改的内容
        case 2: //这里填写从version2到下一个version更改的内容
        ...
        default:break;
    }
}
```
注意其中的case中的代码执行完并没有break,原因在于，因为我们是让用户升级，用户可能从version1直接升级到version3，而这个时候要更新的是从1->2的操作，2->3的更新操作。这种方式能让所有版本的oldVersion的用户升级到最新版。当然如果使用这种方式的话，在onCreate中的内容一定要更新为当前最新版本。

#### 添加数据

当我们通过getWritableDatabase()方法拿到SQLiteDatabase对象后，就可以对数据库进行操作，比如我们的添加数据操作，需要借助ContentValues对象。

添加数据需要使用insert()方法，这个方法专门用于添加数据的，它接收三个参数，第一个参数是表名，第二个置为空，第三个就是ContentValues对象。

直接看代码

```
SQLiteDatabase db = helper.getWritableDatabase();
ContentValues values = new ContentValues();
values.put("color","红");
values.put("size","2");
values.put("name","法拉利");
db.insert("SqlName",null,values);
```
这样就成功添加了一行数据。

#### 更新数据

```
db.update("SqlName",values,"name = ?",new String[]{"法拉第"});
```
更新数据需要把更新的数据放入ContentValues中，并且在update参数的后两位指定where的内容，比如上述代码表示的就是 update xxxxx in SqlName where name = “法拉第”

#### 删除数据

比update参数少了一个ContentValues类型的参数，同样需要两个参数来指定where内容
如

```
db.delete("SqlName","size >= ?",new String[]{"2"});
```
注意约束条件要使用String对象。

#### 查询数据

查询数据需要使用query方法，而该方法最简单的重载都需要传递7个参数

|query方法的参数|	对应的SQL部分|	描述|
|---|---|---|
|table	|from table_name|	指定查询的表名|
|columns	|select column1,column2	|指定查询的列名|
|selection	|where column = value|	指定where约束条件|
|selectionArgs	|-	|为where条件占位符提供具体值|
|groupBy	|groub by column	|指定group by的列名|
|having	|having column = value|	对group by的进一步约束|
|orderBy	|order by column1,column2|	指定排序方式|
使用方法如：Cursor cursor = db.query("SqlName",null,"name=?",new String[]{"法拉第"},null,null,null)

该方法返回的值是一个Cursor对象，通过Cursor对象，我们可以得到查询的每一个行的参数

```
while(cursor.moveToNext())
{
	String name = cursor.getString(cursor.getColumnIndex("name"));
    ...
}
```
当然我们也可以通过原生语言来访问数据库。
如
添加数据：db.execSQL("insert into SqlName(name,size) values(?,?)",new String[]{"法拉第","5"})
更新数据：db.execSQL("update SqlName set name = ? where name = ?",new String[]{"奔驰","法拉第"})
删除数据:db.execSQL("delete from SqlName where name = ?",new String[]{"本田"})
查询数据：db.rawQuery("select * from SqlName",null)

注意除了查询其他三种方式的方法名字都是execSQL,还有一点每个方法都有第二个参数，占位符的值。
对于查询方式，建议使用第二种方式，第一种的参数过长，且不容易记。

#### 使用事务

事务保证某一系列操作，要么都成功，要么都失败。

标准用法：

```
db.beginTransaction(); //开启事务
try{
	//一些数据的操作
    db.setTransactionSuccessful();//如果到这都没异常，就要设置事务成功
}catch(Exception e)
{
	e.printStackTrace();
}finally
{
	db.endTransaction(); //结束事务
}
```
### 内容提供者

内容提供者在前边已经介绍，这里不再赘述。

## Looper、Handler和MessageQueue的关系

[为了研究透彻，专门去看了看源码](http://www.qxgzone.com/2017/01/09/Android-Looper-Handler-Message%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/)

## Activity的启动流程（考察对Framwork的熟悉程度）

（目前还没打算进军Framwork层，所以先放一放）

## 多进程开发的注意事项(Application类区分进程，进程间内存不可见、进程间通讯方式)

### 进程与线程

[进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

### 进程间内存不可见

[Android中单APK应用多进程](http://hubingforever.blog.163.com/blog/static/17104057920126285951877/)

### 进程间通讯方式

安卓中进程间通信还是相对较难的，所以需要耐心仔细的研究。

[AIDL简单使用](http://www.qxgzone.com/2017/03/03/AIDL%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/)

[Android AIDL使用详解](http://blog.csdn.net/stonecao/article/details/6425019)
下面这个是研究源码，涉及很多C++代码，我已经看蒙了，等以后学了JNI再来研究吧！
[Android进程间通信（IPC）机制Binder简要介绍和学习计划](http://blog.csdn.net/luoshengyang/article/details/6618363/)

## 安卓Service保活

[关于 Android 进程保活，你所需要知道的一切](http://www.jianshu.com/p/63aafe3c12af)
[Android开发之如何保证Service不被杀掉](http://blog.csdn.net/mad1989/article/details/22492519)

# 图片处理

## 一般项目中如何加载大图

一般安卓手机的屏幕都比较小，而很多图片的大小都比屏幕大，如果我们直接加载大图片，会白白浪费很多内存，所以一般我们会先把图片压缩到和控件大小相匹配，然后加载。

安卓为我们提供了BitmapFactory工厂方法，内部提供了decodeXXXX等加载图片的方法，这些方法可以直接帮我们加载网页上的，手机内存上的，以及Drawable文件上的。但是默认的使用decode方法加载图片都会消耗内存，消耗大小随图片大小决定

如下图是每隔两秒使用默认方法加载一次1600*900的图片

![](/images/加载图片内存消耗.png)

但是如果我们只是加载不显示，还浪费这么多内存，是不是很亏呢？

但是别急，BitmapFactory里有一个Option类，我们可以通过设置他的一个变量inJustDecodeBounds为true，即可实现加载不消耗内存，而且可以得到图片的一系列参数

代码如下：
```
BitmapFactory.Options options = new BitmapFactory.Options();
options.inJustDecodeBounds = true;
BitmapFactory.decodeResource(getResource(),R.drawable.test,options);//注意第三个参数是必须的
int imgHeight = options.outHeight;
int imgWidth = options.outWidth;
```
如下图是设置了参数后加载图片的内存消耗

![](/images/加载图片不消耗内存.png)

但是如果我们想要加载大图并显示的话怎么办？按上面的方法，是无法显示的，这个时候就需要用到压缩技术了。

## 图片压缩的方式

### 第一种,比例压缩

接上一节，如果我们要压缩显示大图，Options中有一个参数是inSampleSize,这个参数需要设置一个int值，并且大于1，其含义是，例如我们将其值设为4，则图片长宽都会压缩至原来的1/4，这样加载后就会节约内存，如果值小于1，他将和值等于1一个效果。

所以结合上一节，我们可以有一个思路，首先我们将inJustDecodeBounds设为true,并获取图片的信息，然后通过图片的真实长宽和我们想要的长宽作对比，通过对比得到一个合适的inSampleSize值，接着将inJustDecodeBounds设为false，并设置inSampleSize的值，再加载图片，这样就能得到一个合适的压缩的图片了。
如下列代码：

```
int mHeight = 200,mWidth = 300;//假设我们想要的长宽是300*200
float hScale,wScale;//实际长和理想长的比例以及实际宽度和理想宽度比例
BitmapFactory.Options options = new BitmapFactory.Options();
options.inJustDecodeBounds = true;
BitmapFactory.decodeResource(getResources(),R.drawable.test,options);
int imgHeight = options.outHeight;
int imgWidth = options.outWidth;
hScale = (float) ((imgHeight+0.0)/mHeight);
wScale = (float) ((imgWidth+0.0)/mWidth);
options.inSampleSize =
        Math.round(hScale>wScale?hScale:wScale);//选择比例最小的那个，否则显示可能会不清晰
options.inJustDecodeBounds = false;  //注意设置该值
Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.test,options); //再次加载
```
### 第二种，质量压缩

网上搜的代码，直接贴上

```
private Bitmap compressImage(Bitmap image) {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中
		int options = 100;
		while ( baos.toByteArray().length / 1024>100) {	//循环判断如果压缩后图片是否大于100kb,大于继续压缩		
			baos.reset();//重置baos即清空baos
			image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中
			options -= 10;//每次都减少10
		}
		ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中
		Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片
		return bitmap;
	}
```
### 其他方式

其他方式，压缩图片的方式可以根据传入参数的不同使得方法多种多样，可以根据自己喜欢的方式自己定制，比如我们可以传入InputStream等。
还可以将这些写为工具类，比如我的工具类:

```
package com.qxg.qxglibray;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
/**
 * 图片压缩工具
 * Created by Qking on 2016/7/24.
 */
public class BitmapUtils{
    /**
     *质量压缩,将某一图片压缩至小于minSize大小
     */
    public static  Bitmap fromBitmap(Bitmap image,int minSize) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//这里100表示不压缩，把压缩后的数据存放到baos中
        int options = 100;
        while ( baos.toByteArray().length / 1024>minSize) {	//循环判断如果压缩后图片是否大于100kb,大于继续压缩
            baos.reset();//重置baos即清空baos
            image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中
            options -= 10;//每次都减少10
        }
        ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中
        Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片
        return bitmap;
    }
    /**
     * 根据路径进行压缩
     */
    public static Bitmap fromPath(String srcPath,float wantWidth,float wantHeight)
    {
        BitmapFactory.Options options = getOptions(srcPath);
        float wScale = options.outWidth/wantWidth; //比例
        float hScale = options.outHeight/wantHeight;
        options.inSampleSize = Math.round(wScale > hScale?hScale:wScale);
        Bitmap bitmap = BitmapFactory.decodeFile(srcPath,options);
        return bitmap;
    }
    /**
     * 通过给的路径来获取图片，根据比例压缩，然后再质量压缩
     * 传入路径，是因为，我们在读入图片前不能加载图片，要加载图片数据
     */
    public static Bitmap fromPath(String srcPath,float wantWidth,float wantHeight,int minSize,boolean sizeFlag)
    {
        Bitmap bitmap = fromPath(srcPath,wantWidth,wantHeight);
        if(sizeFlag) //如果设置flag，则进行质量压缩
        {
            bitmap = fromBitmap(bitmap,minSize);
        }
        return bitmap;
    }
    /**
     * 通过InputStream来获取图片并压缩
     */
    public static Bitmap fromInputStream(InputStream in,float wantWidth,float wantHeight)
    {
        BitmapFactory.Options options = getOptions(in);
        float wScale = options.outWidth/wantWidth; //比例
        float hScale = options.outHeight/wantHeight;
        options.inSampleSize = Math.round(wScale > hScale?hScale:wScale);
        Bitmap bitmap = BitmapFactory.decodeStream(in,null,options);
        return bitmap;
    }
    /**
     *不加载图片获取图片信息
     */
    public static BitmapFactory.Options getOptions(String srcPath)
    {
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(srcPath,options);
        options.inJustDecodeBounds = false;
        return options;
    }
    public static BitmapFactory.Options getOptions(InputStream in)
    {
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeStream(in,null,options);
        options.inJustDecodeBounds = false;
        return options;
    }
}
```
### 如何不压缩图片加载高清图

[Android 高清加载巨图方案 拒绝压缩图片](http://blog.csdn.net/lmj623565791/article/details/49300989/)

### 图片加载过程中，一般会使用缓存，这个缓存的主要作用是什么

一般我们加载图片少的时候，只需要使用压缩图片的方式就能节约内存，但是平常开发中，我们需要在RecyclerView，ListView,GridView等加载图片，滑动屏幕时，会有一些图片消失在屏幕上，而滑回来的时候，这些图片又要加载到上面，如果重新加载是肯定会消耗很多内存的，所以使用到了缓存的技术，常用的是LruCache。目前使用的最广泛的是三级缓存技术，即使：内存，文件，网络缓存。流程是加载一个图片，首先从内存缓存中寻找，如果没有，寻找硬盘中的缓存，最后才通过Http访问网络。

光说没用，研究一个熟悉框架，我们才能更加容易懂得缓存策略。接下来准备研究Glide源码

### 谈谈自己熟悉的图片加载框架

—-看Glide源码

## Resource相关

### .9图片的意义

例如我的QQ中的消息框，如果不使用.9图片，对于文字所占空间不同的情况下，会使得消息框随着空间变化，如进行拉伸等。这样显示的消息框就不太自然，会发生图像失真。.9图片可以指定某一区域不会随空间而拉伸。

[.9图片的作用](http://www.cnblogs.com/vanezkw/archive/2012/07/19/2599092.html)
[点九图简单介绍及制作教程](http://www.ui.cn/detail/48906.html)

### style和theme的作用及用法

[Android中的style和theme](http://blog.sina.com.cn/s/blog_62f28d560100ucl7.html)
[Android：Style和Theme](http://www.cnblogs.com/tinyphp/p/3826098.html)
[Android中Style和Theme的使用](http://blog.csdn.net/wuxianglong/article/details/6337945)

###  dpi,sp,px的区别以及转换关系

[Android中常用单位(dpi、px、dp、sp)](http://blog.csdn.net/lirui0822/article/details/38388793)

重要公式：px = dp*(dpi/160)

### raw和 assets文件夹的作用，二者何区别

android studio中是没有assets和raw文件夹的，如果想要使用这两个文件夹，就需要在src/main中创建。

[raw与assets区别](http://www.cnblogs.com/lianghui66/p/3248636.html)

### Android系统如何在多个资源文件夹下查找匹配最合适的资源

根据屏幕的dpi大小，匹配相对应的资源，如果没找到对应资源，使用默认的。

## 虚拟机

### JAVA内存模型

### Android虚拟机的特点

### Dalvik和Art的区别

### 熟悉垃圾回收的实现机制，了解虚拟机的GC类型

## View相关

### 常用组件的使用：ListView、RecyclerView及Adapter的使用

ListView的简单用法，是借助于ArrayAdapter，如

```
ListView listView = findViewById(R.id.listView);
list.setAdapter(new ArrayAdapter`<String>(this,android.R.layout.simple_list_item_1,data));
```
这样，ListView就可以显示一条条的data的内容了。

对于复杂一点的使用，就是自定义显示的layout。
首先，要为ListView中的item指定布局–mylayout.xml
其次自定义适配器MyAdapter并继承与ArrayAdapter，重写其中的getView方法。而getView方法中就要开始加载mylayout布局了。重写如下

```
public View getView(int position,View convertView,ViewGroup parent)
{
	View view = LayoutInflater.from(getContext()).inflate(resourceId,null);
    XXX xx = view.findViewById(R.id.xx);
    xx.setXXX();
    return view;
}
```
而在安卓5.0后，一般都开始使用RecyclerView，那么我们就要知道RecyclerView的用法。
查看下列博文：
[Android RecyclerView 使用完全解析 体验艺术般的控件](http://blog.csdn.net/lmj623565791/article/details/45059587)

### View之间的继承关系
![](/images/View继承关系.jpg)


### Invalidate与postInvalidate的区别

两者都是实现View的重绘，区别就是在post上。我们知道使用子线程来更新主线程的View时候，可以使用handler的post方法，其实postInvalidate方法也是用于子线程中。

### 自定义View的实现方式(根据项目经验询问相关组件)。

自定义View需要继承View的一些子类或者继承自View，并重写其中的有关方法。

一些重要的方法：

onFinishInflate()从XML加载组件后回调
onSizeChanged()组件大小改变时回调
onMeasure回调该方法进行测量
onLayout回调该方法确定显示的位置
onTouchEvent监听到触摸事件时回调
#### 首先是View的测量onMeasure()

Android系统提供了一个短小精悍却功能强大的类MeasureSpec类，通过该类帮助我们测量View,该类是一个32位的int值，其中高2位为测量模式，其余为测量的大小。
测量的模式为以下三种：
EXACTLY:当控件的layout_width或layout_height指定为具体数值时，或指定为match_parent时，系统使用的EXACTLY模式。
AT_MOST:当layout_width或layout_height指定为wrap_content时，为AT_MOST模式
UNSPCIFIED:View想多大就多大
View类默认的onMeasure()方法只支持EXACTLY模式，所以如果在自定义控件的时候，不重写onMeasure()方法，就只能使用EXACTLY模式。通过MeasureSpec这个类，我们就获取了View的测量模式和测量值。默认的onMeasure()方法是：

```
protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
super.onMeasure(widthMeasureSpec,heightMeasureSpec);
}
```
查看父类中的onMeasure()方法，发现其最终调用setMeasuredDimension()方法将最后测量的宽高值设置进去。

```
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}
```
所以如果重写onMeasure方法时，可以不必使用supre.onMeasure方法，而是直接调用setMeasuredDimension方法即可。但是在使用该方法前，需要得到用户为该View传递测量参数。在使用setMeasuredDimension方法前要对onMeasuer传入的参数进行预处理，判断其宽度或者高度使用的模式，如果是EXACTLY模式，则直接返回该测量值，如果为AT_MOST则返回我们想要的最小值(根据情况自己定义)

#### 接着是View的绘制

测量完成，当然是View的绘制onDraw(Canvas canvas)方法,其父类的onDraw()方法是空的，什么也没写，所以onDraw()方法的重写的必要的。其中Canvas就是画布类，在往这个画布上画东西时，首先要自定义画笔，即Paint。定义完画笔后，就可以使用canvas的一系列的drawXXXX方法来绘制我们想要的图形了，比如canvas.drawText用于绘制文字，canvas.drawArc用于绘制弧形。

### 自定义ViewGroup

首先要明白，ViewGroup从名字上来看，就可以知道，ViewGroup是一些列View的组合，如果我们想要自定义的控件，需要包含2个或2个以上的View，比如TextView，ImageView等，就需要自定义ViewGroup。
自定义ViewGroup与自定义View所不同的是，自定义ViewGroup必须重写onLayout方法，而不必重写onDraw方法

ViewGroup的测量，如果是wrap_content时，就会遍历其子View，获得所有子View的大小，从而决定自己的大小。测量时，通过遍历所有子View，并调用子View的Measure方法来获得每个子View的测量结果，ViewGroup的onMeasure()方法并没有实现什么，所以还是需要自己重写该方法。

比如

```
protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
super.onMeasure(widthMeasureSpec,heightMeasureSpec);
int count = getChildCount();
    for(int i=0;i<'count;i++){
        View childView = getChildAt(i);
        measureChild(childView,widthMeasureSpec,heightMeasureSpec); //遍历子View进行进行测量,其中第二个参数和第三个参数是子View应该占据的大小。
    }
}
```
接下来就是onLayout方法，该方法的目的是确定每个子View的放置位置，使用child.layout(x,y,x1,y2)
来设置子View的位置，注意，在调用该方法前，可以使用child.getVisibility判断该View是否需要显示。比如：

```
protected void onLayout(boolean changed,int l,int t,int r,int b){
	int childCount = getChildCount();
    //设置ViewGroup的宽高
    MarginLayoutParams mlp = (MarginLayoutParams)getLayoutParams();
    mlp.height = mScreenHeight * childCount;
    setLayoutParams(mlp);
    
    for(int i = 0;i<childCount;i++){
    	View child = getChildAt(i);
        if(child.getVisibility()!= View.GONE){
        	child.layout(l,i*mScreenHeight,
            			r,(i+1)*mScreenHeight);
        }
    }
```


### 小的总结
View的绘制入口在这：performTraversals

performTraversals():
```
    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);  
    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);  
```

其中mWidth,mHeight是固定的,表示当前窗口大小.lp.width,lp.height也是已经固定的,是MATCH_PARENT.

getRootMeasureSpec():
```
private static int getRootMeasureSpec(int windowSize, int rootDimension) {  
    int measureSpec;  
    switch (rootDimension) {  
  
    case ViewGroup.LayoutParams.MATCH_PARENT:  
        // Window不能调整其大小，强制使根视图大小与Window一致  
        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);  
        break;  
    case ViewGroup.LayoutParams.WRAP_CONTENT:  
        // Window可以调整其大小，为根视图设置一个最大值  
        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);  
        break;  
    default:  
        // Window想要一个确定的尺寸，强制将根视图的尺寸作为其尺寸  
        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);  
        break;  
    }  
    return measureSpec;  
}  
```

这就知道了,根试图的onMeasure所传递的widthMeauSpec就是屏幕的大小.

一般View的onMeasure中传入的值是这么来的,调用measureChildren
```
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {  
    final int size = mChildrenCount;  
    final View[] children = mChildren;  
    for (int i = 0; i < size; ++i) {  
        final View child = children[i];  
        if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {  
            measureChild(child, widthMeasureSpec, heightMeasureSpec);  
        }  
    }  
}  



protected void measureChild(View child, int parentWidthMeasureSpec,  
        int parentHeightMeasureSpec) {  
    // 获取子元素的布局参数  
    final LayoutParams lp = child.getLayoutParams();  
  
    /* 
     * 将父容器的测量规格已经上下和左右的边距还有子元素本身的布局参数传入getChildMeasureSpec方法计算最终测量规格 
     */  
    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,  
            mPaddingLeft + mPaddingRight, lp.width);  
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,  
            mPaddingTop + mPaddingBottom, lp.height);  
  
    // 调用子元素的measure传入计算好的测量规格  
    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);  
}  


public static int getChildMeasureSpec(int spec, int padding, int childDimension) {  
    // 获取父容器的测量模式和尺寸大小  
    int specMode = MeasureSpec.getMode(spec);  
    int specSize = MeasureSpec.getSize(spec);  
  
    // 这个尺寸应该减去内边距的值  
    int size = Math.max(0, specSize - padding);  
  
    // 声明临时变量存值  
    int resultSize = 0;  
    int resultMode = 0;  
  
    /* 
     * 根据模式判断 
     */  
    switch (specMode) {  
    case MeasureSpec.EXACTLY: // 父容器尺寸大小是一个确定的值  
        /* 
         * 根据子元素的布局参数判断 
         */  
        if (childDimension >= 0) { //如果childDimension是一个具体的值  
            // 那么就将该值作为结果  
            resultSize = childDimension;  
  
            // 而这个值也是被确定的  
            resultMode = MeasureSpec.EXACTLY;  
        } else if (childDimension == LayoutParams.MATCH_PARENT) { //如果子元素的布局参数为MATCH_PARENT  
            // 那么就将父容器的大小作为结果  
            resultSize = size;  
  
            // 因为父容器的大小是被确定的所以子元素大小也是可以被确定的  
            resultMode = MeasureSpec.EXACTLY;  
        } else if (childDimension == LayoutParams.WRAP_CONTENT) { //如果子元素的布局参数为WRAP_CONTENT  
            // 那么就将父容器的大小作为结果  
            resultSize = size;  
  
            // 但是子元素的大小包裹了其内容后不能超过父容器  
            resultMode = MeasureSpec.AT_MOST;  
        }  
        break;  
  
    case MeasureSpec.AT_MOST: // 父容器尺寸大小拥有一个限制值  
        /* 
         * 根据子元素的布局参数判断 
         */  
        if (childDimension >= 0) { //如果childDimension是一个具体的值  
            // 那么就将该值作为结果  
            resultSize = childDimension;  
  
            // 而这个值也是被确定的  
            resultMode = MeasureSpec.EXACTLY;  
        } else if (childDimension == LayoutParams.MATCH_PARENT) { //如果子元素的布局参数为MATCH_PARENT  
            // 那么就将父容器的大小作为结果  
            resultSize = size;  
  
            // 因为父容器的大小是受到限制值的限制所以子元素的大小也应该受到父容器的限制  
            resultMode = MeasureSpec.AT_MOST;  
        } else if (childDimension == LayoutParams.WRAP_CONTENT) { //如果子元素的布局参数为WRAP_CONTENT  
            // 那么就将父容器的大小作为结果  
            resultSize = size;  
  
            // 但是子元素的大小包裹了其内容后不能超过父容器  
            resultMode = MeasureSpec.AT_MOST;  
        }  
        break;  
  
    case MeasureSpec.UNSPECIFIED: // 父容器尺寸大小未受限制  
        /* 
         * 根据子元素的布局参数判断 
         */  
        if (childDimension >= 0) { //如果childDimension是一个具体的值  
            // 那么就将该值作为结果  
            resultSize = childDimension;  
  
            // 而这个值也是被确定的  
            resultMode = MeasureSpec.EXACTLY;  
        } else if (childDimension == LayoutParams.MATCH_PARENT) { //如果子元素的布局参数为MATCH_PARENT  
            // 因为父容器的大小不受限制而对子元素来说也可以是任意大小所以不指定也不限制子元素的大小  
            resultSize = 0;  
            resultMode = MeasureSpec.UNSPECIFIED;  
        } else if (childDimension == LayoutParams.WRAP_CONTENT) { //如果子元素的布局参数为WRAP_CONTENT  
            // 因为父容器的大小不受限制而对子元素来说也可以是任意大小所以不指定也不限制子元素的大小  
            resultSize = 0;  
            resultMode = MeasureSpec.UNSPECIFIED;  
        }  
        break;  
    }  
  
    // 返回封装后的测量规格  
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);  
}  

```
所以最终的结果是由父View和当前View共同作用的结果,一般不用理会.


如果是viewgroup,其中并没有调用measureChildren方法,只是有这个方法,但是没有调用,所以在定义ViewGroup的时候,一定要重写onMeasure方法,在方法中调用measureChildren



注意每个子View的onMeasure传入的值都是期望值(其结果一般由父View的LayoutParams和子View的共同决定的),比如一般都是父View的剩余最大值,其最终的确定值,一般还是要经过onLayout,才能真正确定.

其中layout()方法中,是调用了setFrame才最终确定了view的宽度和高度,所以不要以为onMeasure方法重写完就完事了,可能会出现意外情况,要注意.

但是ViewGroup就不一样了,其只需要循环调用child.layout就可以,不用去管layout是如何操作的.

一般View的onMeasure的套路是一样的,如下:

```
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        //super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        setMeasuredDimension(getMeasuredSize(widthMeasureSpec),
                getMeasuredSize(heightMeasureSpec));
    }

    private int getMeasuredSize(int measureSpec){
        int result = 0; // 临时变量存取结果值

        int mode = MeasureSpec.getMode(measureSpec);
        int size = MeasureSpec.getSize(measureSpec);

        switch (mode){
            case MeasureSpec.EXACTLY:
                result = size; // 如果是EXACTLY,儿子不让爹为难,就取爹的大小吧
                break;
            case MeasureSpec.AT_MOST:
                result = Math.min(200,size);  //即有一个限定值,儿子不能超过限定值,就取自己想要的最小值和父View值两者的最小值.
                break;
        }
        return result;
    }

```

而ViewGroup的套路更加简洁如下:

```
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {  
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);    //不能省,如果省还需要调用setMeasuredDiemension
  
        /* 
         * 如果有子元素 
         */  
        if (getChildCount() > 0) {  
            // 那么对子元素进行测量  
            measureChildren(widthMeasureSpec, heightMeasureSpec);  
        }  
    }  
```

而View的onLayout的套路也一样,或者基本上不用重写,因为ViewGroup会调用子View的layout方法来绘制子View的位置,如果View想要自定义自己的位置,可以使用setFrame()来写,但是这样可能会出现问题.


同样ViewGroup的layout也是一样的套路(如果不重写,每个View的位置基本一样),如:
```

//摘抄网上的代码,这里仅仅是一个样例,该样例是子View从上往下以此排列,注意了.
protected void onLayout(boolean changed, int l, int t, int r, int b) {  
  
    /* 
     * 如果有子元素 
     */  
    if (getChildCount() > 0) {  
        // 声明一个临时变量存储高度倍增值  
        int mutilHeight = 0;  
  
        // 那么遍历子元素并对其进行定位布局  
        for (int i = 0; i < getChildCount(); i++) {  
            // 获取一个子元素  
            View child = getChildAt(i);  
  
            // 通知子元素进行布局  
            child.layout(0, mutilHeight, child.getMeasuredWidth(), child.getMeasuredHeight() + mutilHeight);  
  
            // 改变高度倍增值  
            mutilHeight += child.getMeasuredHeight();  
        }  
    }  
}  
```

### 事件分发机制
[Android事件分发完全解析之为什么是她](http://blog.csdn.net/aigestudio/article/details/44260301)

# 牛客上翻到的面试题

## 美团

1.ListView的复用问题,如何复用:
[ListView复用](http://blog.csdn.net/u011692041/article/details/53099584)
2.不使用ViewHolder如何复用View.
???

3.描述了一个场景，一个listView共有200项，10项可以占满屏幕，从顶部一直滑到底部，期间不向上滑，使用了复用的情况下，getView方法调用调用多少次，convertView初始化了几次。
getView会一直调用,而convertView可能11或12次,因为上方未完全滑出,也会初始化convertView
4.事件拦截机制
5.contentprovider
6.浏览器跳转App
[猛戳](http://blog.csdn.net/jiangwei0910410003/article/details/23940445)
7.说一下fragment和activity的通信
。。这不是我阿里电面时的问题么，使用Intent，调用接口(注意Activity可以通过getFragmentManager().findFragmentById来获取Fragment，Fragment通过getActivity()来获取Activity)，
8.fragment内部怎样嵌套fragment。
通过getChildFragmentManager。注意Fragment中的getFragmentManager()是获取的把当前Fragment添加进来的Manager。
9. 静态内部类与非静态内部类区别
10. 内存泄露
11.什么样的对象应该被回收
12.匿名内部类有没有构造方法
13.匿名内部类使用局部变量为什么是final。
