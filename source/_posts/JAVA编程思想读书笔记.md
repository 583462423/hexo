---
title: JAVA编程思想读书笔记
date: 2017-03-19 15:34:04
tags: Java
---
.
<!--more-->

对于以下代码:
```
int a = 1;

for(int j=0; j<=100;j++){
    int a = 2;
} 
```
在外部定义了a后,在for内部又定义了a,在C/C++中是合法的,但是在Java中是不合法的.

`float a = 1e-43f`,f是必须的,不指定会将1e-43作为double处理.如果不指定,将有提示. 

finalize()方法与C++里的析构函数并不是同等概念.为什么要有这个方法,原因在于,Java可能会调用C/C++语言中malloc来分配内存,而释放内存还是通过free(),Java中并没有这种方法,所以需要finalize来调用C/C++的free()来释放内存.这是一种解释.

finalize()方法一般不用于内存清除工作,而是用于最后的检查,比如某一打开的文件是否关闭,某一业务是否完成等等.

垃圾回收机制的引用计数方法管理引用开销不大,但如果对象间互有引用,可能会出现"对象应该被回收,但引用计数器不为0"的情况.
引用计数器常用来说明垃圾收集器的工作方式,但似乎从未应用于任何一种JAVA虚拟机实现中.

垃圾回收机制一般采用的是可达性分析法:对于任何"活"的对象,一定能最终追溯到其存活在堆栈或静态存储区之中的引用.所以,如果从堆栈和静态存储区开始,遍历所有的引用,就能找到所有"活"的对象.

每个成员变量都有初始值,这些初始值在打印的时候会突出其作用,但是如果要使用这些变量的时,必须要初始化这些变量,注意初始化和初始值并不是同一概念.

每个.java文件中只能有一个public类,如果额外定义其他类,将不会被外部看到,这些类只是为public类提供支持.

import static静态导入是JDK1.5中的新特性。一般我们导入一个类都用 import com.....ClassName;而静态导入是这样：import static com.....ClassName.*;这里的多了个static，还有就是类名ClassName后面多了个 .* ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名 的方式来调用。

private方法默认是final形的.

final类中的所有方法,隐式都为final形.
